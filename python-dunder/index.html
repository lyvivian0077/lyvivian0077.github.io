<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>5种下划线 - 总有刁民想要害朕</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "5\u79cd\u4e0b\u5212\u7ebf";
        var mkdocs_page_input_path = "python-dunder.markdown";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QXRGWVKZW2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QXRGWVKZW2');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 总有刁民想要害朕
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">ansbile</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile/">ansbileオプション</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile_async/">ansbile_async</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../awk/">awk</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../MB-MiB%E7%9A%84%E5%8C%BA%E5%88%AB/">MB_MiB的区别</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">MegaRAID</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../megacli/">megacli</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../megaraid/">megaraid</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MySQL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Explain详解与索引最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql/">Mysql参数优化</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql-table/">MySQL-table</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql%E3%82%92%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/">MySQLビルド</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python Tips</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../python-styleguide/">Python风格规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-config/">Python程序配置文件管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-decorator/">装饰器</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">5种下划线</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#1-_var">1. 单前导下划线 _var</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2-var_">2. 单末尾下划线 var_</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#3-__var">3. 双前导下划线 __var</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4-var">4. 双前导和双末尾下划线 var</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#5-_">5.单下划线 _</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-function/">传入参数的几种方法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python/">非常规的技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-mysql/">操作mysql基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python-Re-%E6%A8%A1%E5%9D%97%E8%B6%85%E5%85%A8%E8%A7%A3%E8%AF%BB/">Re 模块</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/">字符串拼接总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C/">代码并行</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Regular-Expression/">正規表現</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../taged-VLAN%E3%81%A8untagedVLAN%E3%81%AE%E9%81%95%E3%81%84/">タグVLAN</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sar/">sar</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Bash%E7%BC%96%E7%A8%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/">Bash编程超详细语法总结</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../iptables/">iptables</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../linux-lvm/">linux-lvm</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos7-set-kernel/">centos7-set-kernel</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos-network-device-naming/">centos-network-device-naming</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-Performance/">Linux Performance</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">Linux-shell-逻辑运算符-逻辑表达式详解</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">LVM逻辑卷基本概念及LVM的工作原理</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../macOS%E8%BD%AF%E4%BB%B6%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E6%9B%B4%E6%96%B010-15/">macOS软件编译时找不到头文件解决方法[更新10.15]</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ubnt/">ubnt</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vim/">VIM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">总有刁民想要害朕</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>Python Tips &raquo;</li>
      <li>5种下划线</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="python5">Python中下划线的5种含义<a class="headerlink" href="#python5" title="Permanent link">&para;</a></h1>
<p>本文介绍了Python中单下划线和双下划线（"dunder"）的各种含义和命名约定，名称修饰（name mangling）的工作原理，以及它如何影响你自己的Python类。</p>
<p>单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。</p>
<p>如果你想知道“Python变量和方法名称中单下划线和双下划线的含义是什么？”，我会尽我所能在这里为你解答。</p>
<p>在本文中，我将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为：</p>
<ul>
<li>单前导下划线：_var</li>
<li>单末尾下划线：var_</li>
<li>双前导下划线：__var</li>
<li>双前导和末尾下划线：__var__</li>
<li>单下划线：_</li>
</ul>
<p>在文章结尾处，你可以找到一个简短的“速查表”，总结了五种不同的下划线命名约定及其含义，以及一个简短的视频教程，可让你亲身体验它们的行为。</p>
<h3 id="1-_var">1. 单前导下划线 _var<a class="headerlink" href="#1-_var" title="Permanent link">&para;</a></h3>
<p>当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python社区一致认为它应该是什么意思，但程序的行为不受影响。</p>
<p>下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。</p>
<p>这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说：</p>
<blockquote>
<p>“嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“
看看下面的例子：</p>
</blockquote>
<pre><code class="language-python">class Test:
   def __init__(self):
       self.foo = 11
       self._bar = 23
</code></pre>
<p>如果你实例化此类，并尝试访问在__init__构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：</p>
<pre><code class="language-python">&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t.foo
11
&gt;&gt;&gt; t._bar
23
</code></pre>
<p>你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。
这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。</p>
<blockquote>
<p>但是，前导下划线的确会影响从模块中导入名称的方式。 </p>
</blockquote>
<p>假设你在一个名为my_module的模块中有以下代码：</p>
<pre><code class="language-python"># This is my_module.py:

def external_func():
   return 23

def _internal_func():
   return 42
</code></pre>
<p>现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的__all__列表）：</p>
<pre><code class="language-python">&gt;&gt;&gt; from my_module import *
&gt;&gt;&gt; external_func()
23
&gt;&gt;&gt; _internal_func()
NameError: &quot;name '_internal_func' is not defined&quot;
</code></pre>
<p>顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。
与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：</p>
<pre><code class="language-python">&gt;&gt;&gt; import my_module
&gt;&gt;&gt; my_module.external_func()
23
&gt;&gt;&gt; my_module._internal_func()
42
</code></pre>
<p>我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：</p>
<blockquote>
<p>单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。</p>
</blockquote>
<h3 id="2-var_">2. 单末尾下划线 var_<a class="headerlink" href="#2-var_" title="Permanent link">&para;</a></h3>
<p>有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：</p>
<pre><code class="language-python">&gt;&gt;&gt; def make_object(name, class):
SyntaxError: &quot;invalid syntax&quot;

&gt;&gt;&gt; def make_object(name, class_):
        pass
</code></pre>
<p>总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。</p>
<h3 id="3-__var">3. 双前导下划线 __var<a class="headerlink" href="#3-__var" title="Permanent link">&para;</a></h3>
<p>到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。</p>
<p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p>
<p>这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。
我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：</p>
<pre><code class="language-python">class Test:
   def __init__(self):
       self.foo = 11
       self._bar = 23
       self.__baz = 23
</code></pre>
<p>让我们用内置的dir()函数来看看这个对象的属性：</p>
<pre><code class="language-python">&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; dir(t)
['_Test__baz', '__class__', '__delattr__', '__dict__', '__dir__',
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
'__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__',
'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'__weakref__', '_bar', 'foo']
</code></pre>
<p>以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称foo，_bar和__baz
- 我保证你会注意到一些有趣的变化。
  - self.foo变量在属性列表中显示为未修改为foo。
  - self._bar的行为方式相同 - 它以_bar的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。
  - 然而，对于self.__baz而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。</p>
<p>__baz出什么情况了？</p>
<p>如果你仔细观察，你会看到此对象上有一个名为_Test__baz的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。</p>
<p>让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：</p>
<pre><code class="language-python">class ExtendedTest(Test):
   def __init__(self):
       super().__init__()
       self.foo = 'overridden'
       self._bar = 'overridden'
       self.__baz = 'overridden'
</code></pre>
<p>现在，你认为foo，_bar和__baz的值会出现在这个ExtendedTest类的实例上吗？ 我们来看一看：</p>
<pre><code class="language-python">&gt;&gt;&gt; t2 = ExtendedTest()
&gt;&gt;&gt; t2.foo
'overridden'
&gt;&gt;&gt; t2._bar
'overridden'
&gt;&gt;&gt; t2.__baz
AttributeError: &quot;'ExtendedTest' object has no attribute '__baz'&quot;
</code></pre>
<p>等一下，当我们尝试查看t2 .__ baz的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性：</p>
<pre><code class="language-python">&gt;&gt;&gt; dir(t2)
['_ExtendedTest__baz', '_Test__baz', '__class__', '__delattr__',
'__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattribute__', '__gt__', '__hash__', '__init__', '__le__',
'__lt__', '__module__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', '__weakref__', '_bar', 'foo', 'get_vars']
</code></pre>
<p>正如你可以看到__baz变成_ExtendedTest__baz以防止意外修改：</p>
<pre><code class="language-python">&gt;&gt;&gt; t2._ExtendedTest__baz
'overridden'
</code></pre>
<p>但原来的_Test__baz还在：</p>
<pre><code class="language-python">&gt;&gt;&gt; t2._Test__baz
42
</code></pre>
<p>双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：</p>
<pre><code class="language-python">class ManglingTest:
   def __init__(self):
       self.__mangled = 'hello'

   def get_mangled(self):
       return self.__mangled

&gt;&gt;&gt; ManglingTest().get_mangled()
'hello'
&gt;&gt;&gt; ManglingTest().__mangled
AttributeError: &quot;'ManglingTest' object has no attribute '__mangled'&quot;
</code></pre>
<p>名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（"dunders"）开头的所有名称：</p>
<pre><code class="language-python">class MangledMethod:
   def __method(self):
       return 42

   def call_it(self):
       return self.__method()

&gt;&gt;&gt; MangledMethod().__method()
AttributeError: &quot;'MangledMethod' object has no attribute '__method'&quot;
&gt;&gt;&gt; MangledMethod().call_it()
42
</code></pre>
<p>这是另一个也许令人惊讶的运用名称修饰的例子：</p>
<pre><code class="language-python">_MangledGlobal__mangled = 23

class MangledGlobal:
   def test(self):
       return __mangled

&gt;&gt;&gt; MangledGlobal().test()
23
</code></pre>
<p>在这个例子中，我声明了一个名为_MangledGlobal__mangled的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以__mangled来引用_MangledGlobal__mangled全局变量。</p>
<p>Python解释器自动将名称__mangled扩展为_MangledGlobal__mangled，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。</p>
<p>有很多要吸收的内容吧。</p>
<p>老实说，这些例子和解释不是从我脑子里蹦出来的。我作了一些研究和加工才弄出来。我一直使用Python，有很多年了，但是像这样的规则和特殊情况并不总是浮现在脑海里。</p>
<p>有时候程序员最重要的技能是“模式识别”，而且知道在哪里查阅信息。如果您在这一点上感到有点不知所措，请不要担心。慢慢来，试试这篇文章中的一些例子。</p>
<p>让这些概念完全沉浸下来，以便你能够理解名称修饰的总体思路，以及我向您展示的一些其他的行为。如果有一天你和它们不期而遇，你会知道在文档中按什么来查。</p>
<h3 id="4-var">4. 双前导和双末尾下划线 <em>var</em><a class="headerlink" href="#4-var" title="Permanent link">&para;</a></h3>
<p>也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：</p>
<pre><code class="language-python">class PrefixPostfixTest:
   def __init__(self):
       self.__bam__ = 42

&gt;&gt;&gt; PrefixPostfixTest().__bam__
42
</code></pre>
<p>但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，<strong>init__对象构造函数，或__call</strong> --- 它使得一个对象可以被调用。
这些dunder方法通常被称为神奇方法 - 但Python社区中的许多人（包括我自己）都不喜欢这种方法。
最好避免在自己的程序中使用以双下划线（“dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</p>
<h3 id="5-_">5.单下划线 _<a class="headerlink" href="#5-_" title="Permanent link">&para;</a></h3>
<p>按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。
例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值：</p>
<pre><code class="language-python">&gt;&gt;&gt; for _ in range(32):
...    print('Hello, World.')
</code></pre>
<p>你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。
在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场：</p>
<pre><code class="language-python">&gt;&gt;&gt; car = ('red', 'auto', 12, 3812.4)
&gt;&gt;&gt; color, _, _, mileage = car

&gt;&gt;&gt; color
'red'
&gt;&gt;&gt; mileage
3812.4
&gt;&gt;&gt; _
12
</code></pre>
<p>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。
这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p>
<pre><code class="language-python">&gt;&gt;&gt; 20 + 3
23
&gt;&gt;&gt; _
23
&gt;&gt;&gt; print(_)
23

&gt;&gt;&gt; list()
[]
&gt;&gt;&gt; _.append(1)
&gt;&gt;&gt; _.append(2)
&gt;&gt;&gt; _.append(3)
&gt;&gt;&gt; _
[1, 2, 3]
</code></pre>
<p>Python下划线命名模式 - 小结
以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义：</p>
<p><img alt="速查表" src="/assets/python_dunder.jpg" /></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../python-decorator/" class="btn btn-neutral float-left" title="装饰器"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../python-function/" class="btn btn-neutral float-right" title="传入参数的几种方法">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright © 2022 - 2023 - lyvivian0077</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../python-decorator/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../python-function/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
