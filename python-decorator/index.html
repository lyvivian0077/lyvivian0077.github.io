<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>装饰器 - 总有刁民想要害朕</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u88c5\u9970\u5668";
        var mkdocs_page_input_path = "python-decorator.markdown";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QXRGWVKZW2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QXRGWVKZW2');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 总有刁民想要害朕
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">ansbile</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile/">ansbileオプション</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile_async/">ansbile_async</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../awk/">awk</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../MB-MiB%E7%9A%84%E5%8C%BA%E5%88%AB/">MB_MiB的区别</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">MegaRAID</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../megacli/">megacli</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../megaraid/">megaraid</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MySQL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Explain详解与索引最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql/">Mysql参数优化</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql-table/">MySQL-table</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql%E3%82%92%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/">MySQLビルド</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python Tips</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../python-styleguide/">Python风格规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-config/">Python程序配置文件管理</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">装饰器</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-dunder/">5种下划线</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-function/">传入参数的几种方法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python/">非常规的技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-mysql/">操作mysql基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python-Re-%E6%A8%A1%E5%9D%97%E8%B6%85%E5%85%A8%E8%A7%A3%E8%AF%BB/">Re 模块</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/">字符串拼接总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C/">代码并行</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Regular-Expression/">正規表現</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../taged-VLAN%E3%81%A8untagedVLAN%E3%81%AE%E9%81%95%E3%81%84/">タグVLAN</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sar/">sar</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Bash%E7%BC%96%E7%A8%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/">Bash编程超详细语法总结</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../iptables/">iptables</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../linux-lvm/">linux-lvm</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos7-set-kernel/">centos7-set-kernel</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos-network-device-naming/">centos-network-device-naming</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-Performance/">Linux Performance</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">Linux-shell-逻辑运算符-逻辑表达式详解</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">LVM逻辑卷基本概念及LVM的工作原理</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../macOS%E8%BD%AF%E4%BB%B6%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E6%9B%B4%E6%96%B010-15/">macOS软件编译时找不到头文件解决方法[更新10.15]</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ubnt/">ubnt</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vim/">VIM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">总有刁民想要害朕</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>Python Tips &raquo;</li>
      <li>装饰器</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <blockquote>
<p>装饰器是一个非常重要的 Python 概念，可能算是进阶的一大门槛。本文比较全面地对装饰器进行了介绍，并且配备了详细的代码示例，推荐阅读。</p>
</blockquote>
<p>作者：Toby
原文：https://betacat.online/posts/python-decorator/index.html</p>
<p>Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。</p>
<h2 id="_1">为什么需要装饰器<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>我们假设你的程序实现了 <code>say_hello ()</code> 和 <code>say_goodbye ()</code> 两个函数。</p>
<pre><code class="language-python">def say_hello():
   print &quot;hello!&quot;

def say_goodbye():
   print &quot;hello!&quot;  # bug here

if __name__ == '__main__':
   say_hello()
   say_goodbye()
</code></pre>
<p>但是在实际调用中，我们发现程序出错了，上面的代码打印了两个 hello 。经过调试你发现是 <code>say_goodbye ()</code> 出错了。老板要求调用每个方法前都要记录进入函数的时间和名称，比如这样：</p>
<pre><code class="language-python">[DEBUG] 2016 - 10 - 27 11:11:11 - Enter say_hello()
Hello!

[DEBUG] 2016 - 10 - 27 11:11:11 - Enter say_goodbye()
Goodbye!
</code></pre>
<p>好，小 A 是个毕业生，他是这样实现的。</p>
<pre><code class="language-python">def say_hello():
   print &quot;[DEBUG]: enter say_hello()&quot;
   print &quot;hello!&quot;

def say_goodbye():
   print &quot;[DEBUG]: enter say_goodbye()&quot;
   print &quot;hello!&quot;

if __name__ == '__main__':
   say_hello()
   say_goodbye()
</code></pre>
<p>很 low 吧？ 嗯是的。小 B 工作有一段时间了，他告诉小 A 应该这样写。</p>
<pre><code class="language-python">def debug():
   import inspect
   caller_name = inspect.stack()[1][3]    
   print &quot;[DEBUG]: enter {}()&quot;.format(caller_name)

def say_hello():
   debug()    
   print &quot;hello!&quot;

def say_goodbye():
   debug()    
   print &quot;goodbye!&quot;

if __name__ == '__main__':
   say_hello()
   say_goodbye()
</code></pre>
<p>是不是好一点？那当然，但是每个业务函数里都要调用一下 debug () 函数，是不是很难受？万一老板说 say 相关的函数不用 debug ， do 相关的才需要呢？</p>
<p>那么装饰器这时候应该登场了。</p>
<blockquote>
<p>装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
</blockquote>
<p>概括的讲，装饰器的作用就是<code>为已经存在的函数或对象添加额外的功能。</code></p>
<p>怎么写一个装饰器</p>
<p>在早些时候  (Python Version &lt; 2.4，2004年以前)，为一个函数添加额外功能的写法是这样的。</p>
<pre><code class="language-python">def debug(func):
   def wrapper():
       print &quot;[DEBUG]: enter {}()&quot;.format(func.__name__)        
       return func()    
   return wrapper

def say_hello():
   print &quot;hello!&quot;

say_hello = debug(say_hello)  # 添加功能并保持原函数名不变
</code></pre>
<p>上面的 debug 函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，下面代码等同于早期的写法。</p>
<pre><code class="language-python">def debug(func):
   def wrapper():
       print &quot;[DEBUG]: enter {}()&quot;.format(func.__name__)        
       return func()    
   return wrapper

@debug
def say_hello():
   print &quot;hello!&quot;
</code></pre>
<p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数 <code>wrapper</code> 接受和原函数一样的参数，比如：</p>
<pre><code class="language-python">def debug(func):
   def wrapper(something):  # 指定一毛一样的参数
       print &quot;[DEBUG]: enter {}()&quot;.format(func.__name__)        
       return func(something)    
   return wrapper  # 返回包装过函数

@debug
def say(something):
   print &quot;hello {}!&quot;.format(something)
</code></pre>
<p>这样你就解决了一个问题，但又多了 N 个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好 Python 提供了可变参数 <code>* args</code> 和关键字参数 <code>** kwargs</code> ，有了这两个参数，装饰器就可以用于任意目标函数了。</p>
<pre><code class="language-python">def debug(func):
   def wrapper(*args, **kwargs):  # 指定宇宙无敌参数
       print &quot;[DEBUG]: enter {}()&quot;.format(func.__name__)        
       print 'Prepare and say...',        
       return func(*args, **kwargs)    
   return wrapper  # 返回

@debug
def say(something):
   print &quot;hello {}!&quot;.format(something)
</code></pre>
<p>至此，你已完全掌握初级的装饰器写法。</p>
<h2 id="_2">高级一点的装饰器<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>带参数的装饰器和类装饰器属于进阶的内容。在理解这些装饰器之前，最好对函数的闭包和装饰器的接口约定有一定了解。(参见http://betacat.online/posts/python- closure/)</p>
<h3 id="_3">带参数的装饰器<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出 log 信息，而且还需指定 log 的级别，那么装饰器就会是这样的。</p>
<pre><code class="language-python">def debug(func):
def logging(level):
   def wrapper(func):
       def inner_wrapper(*args, **kwargs):
           print &quot;[{level}]: enter function {func}()&quot;.format(
               level=level,
               func=func.__name__)            
           return func(*args, **kwargs)        
       return inner_wrapper    
   return wrapper

@logging(level='INFO')
def say(something):
   print &quot;say {}!&quot;.format(something)

@logging(level='DEBUG')
def do(something):
   print &quot;do {}...&quot;.format(something)

if __name__ == '__main__':
   say('hello')
   do(&quot;my work&quot;)
</code></pre>
<p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如 <code>@ logging ( level =' DEBUG ')</code> ，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p>
<h2 id="_4">基于类实现的装饰器<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<p>装饰器函数其实是这样一个接口约束，它必须接受一个 callable 对象作为参数，然后返回一个 callable 对象。在 Python 中一般 callable 对象都是函数，但也有例外。只要某个对象重载了 <code>__call__ ()</code> 方法，那么这个对象就是 callable 的。</p>
<pre><code class="language-python">class Test():
   def __call__(self):
       print 'call me!'t = Test()
t()  # call me
</code></pre>
<p>像 <code>__call__</code> 这样前后都带下划线的方法在 Python 中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p>
<p>回到装饰器上的概念上来，装饰器要求接受一个 callable 对象，并返回一个 callable 对象（不太严谨，详见后文）。那么用类来实现也是也可以的。我们可以让类的构造函数 <code>__init__ ()</code> 接受一个函数，然后重载 <code>__call__ ()</code> 并返回一个函数，也可以达到装饰器函数的效果。</p>
<pre><code class="language-python">class logging(object):
   def __init__(self, func):
       self.func = func    
   def __call__(self, *args, **kwargs):
       print &quot;[DEBUG]: enter function {func}()&quot;.format(
           func=self.func.__name__)        
       return self.func(*args, **kwargs)

@logging
def say(something):
   print &quot;say {}!&quot;.format(something)
</code></pre>
<h2 id="_5">带参数的类装饰器<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载 <code>__call__</code> 方法是就需要接受一个函数并返回一个函数。</p>
<pre><code class="language-python">class logging(object):
   def __init__(self, level='INFO'):
       self.level = level    
   def __call__(self, func):  # 接受函数
       def wrapper(*args, **kwargs):
           print &quot;[{level}]: enter function {func}()&quot;.format(
               level=self.level,
               func=func.__name__)
           func(*args, **kwargs)        
           return wrapper  # 返回函数

@logging(level='INFO')
def say(something):
   print &quot;say {}!&quot;.format(something)
</code></pre>
<h2 id="_6">内置的装饰器<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象，所以更难理解一些。</p>
<h3 id="property">@ property<a class="headerlink" href="#property" title="Permanent link">&para;</a></h3>
<p>在了解这个装饰器前，你需要知道在不使用装饰器怎么写一个属性。</p>
<pre><code class="language-python">def getx(self):
   return self._x
def setx(self, value):
   self._x = value
def delx(self):
   del self._x# create a property
x = property(getx, setx, delx, &quot;I am doc for x property&quot;)
</code></pre>
<p>以上就是一个Python属性的标准写法，其实和Java挺像的，能达到一样的效果但看起来更简单。</p>
<pre><code class="language-python">@property
def x(self): ...
# 等同于
def x(self): ...
x = property(x)
</code></pre>
<p>属性有三个装饰器： <code>setter</code> , <code>getter</code> , <code>deleter</code> ，都是在 <code>property ()</code> 的基础上做了一些封装，因为 <code>setter</code> 和 <code>deleter</code> 是 <code>property ()</code> 的第二和第三个参数，<code>getter</code> 装饰器和不带 <code>getter</code> 的属性装饰器效果是一样的，估计只是为了凑数，本身没有任何存在的意义。经过 <code>@ property</code> 装饰过的函数返回的不再是一个函数，而是一个 <code>property</code> 对象。</p>
<pre><code class="language-python">&gt;&gt;&gt; property()
&lt;property object at 0x10ff07940 &gt;
</code></pre>
<h3 id="classmethod">@ classmethod<a class="headerlink" href="#classmethod" title="Permanent link">&para;</a></h3>
<p>有了 <code>@ property</code> 装饰器的了解，这两个装饰器的原理是差不多的。 <code>@ staticmethod</code> 返回的是一个 <code>staticmethod</code> 类对象，而 <code>@ classmethod</code> 返回的是一个 <code>classmethod</code> 类对象。他们都是调用的是各自的 <code>__init__ ()</code> 构造函数。</p>
<pre><code class="language-python">class classmethod(object):
   &quot;&quot;&quot;
   classmethod(function) -&gt; method
   &quot;&quot;&quot;
   def __init__(self, function):  # for @classmethod decorator
       pass
   # ...
class staticmethod(object):
   &quot;&quot;&quot;
   staticmethod(function) -&gt; method
   &quot;&quot;&quot;
   def __init__(self, function):  # for @staticmethod decorator
       pass
   # ...
class Foo(object):
   @staticmethod
   def bar():
       pass
   # 等同于 bar = staticmethod(bar)
</code></pre>
<p>至此，我们上文提到的装饰器接口定义可以更加明确一些，装饰器必须接受一个 callable 对象，其实它并不关心你返回什么，可以是另外一个 callable 对象（大部分情况），也可以是其他类对象，比如 property 。</p>
<h2 id="_7">装饰器里的那些坑<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<p>装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。</p>
<h3 id="_8">位置错误的代码<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>让我们直接看示例代码。</p>
<pre><code class="language-python">def html_tags(tag_name):
   print 'begin outer function.'
   def wrapper_(func):
       print &quot;begin of inner wrapper function.&quot;
       def wrapper(*args, **kwargs):
           content = func(*args, **kwargs)            
           print &quot;&lt;{tag}&gt;{content}&lt;/{tag}&gt;&quot;.format(tag=tag_name, content=content)               print 'end of inner wrapper function.'
       return wrapper    
   print 'end of outer function'
   return wrapper_@html_tags('b')

def hello(name='Toby'):
   return 'Hello {}!'.format(name)
hello()
hello()
</code></pre>
<p>在装饰器中我在各个可能的位置都加上了 print 语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了。以下是输出结果：</p>
<pre><code class="language-python">begin outer function.
end of outer function
begin of inner wrapper function.
end of inner wrapper function.
&lt;b &gt; Hello Toby!&lt; /b &gt;
&lt;b &gt; Hello Toby!&lt; /b &gt;
</code></pre>
<h3 id="_9">错误的函数签名和文档<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>装饰器装饰过的函数看上去名字没变，其实已经变了。</p>
<pre><code class="language-python">def logging(func):
   def wrapper(*args, **kwargs):
       &quot;&quot;&quot;print log before a function.&quot;&quot;&quot;
       print &quot;[DEBUG] {}: enter {}()&quot;.format(datetime.now(), func.__name__)        
       return func(*args, **kwargs)    
   return wrapper

@logging
def say(something):
   &quot;&quot;&quot;say something&quot;&quot;&quot;
   print &quot;say {}!&quot;.format(something)
print say.__name__  # wrapper
</code></pre>
<p>为什么会这样呢？@等同于这样的写法。</p>
<pre><code class="language-python">say = logging(say)
</code></pre>
<p><code>logging</code> 其实返回的函数名字刚好是 <code>wrapper</code> ，那么上面的这个语句刚好就是把这个结果赋值给 <code>say</code> ， <code>say</code> 的 <code>__name__</code> 自然也就是 <code>wrapper</code> 了，不仅仅是 <code>name</code> ，其他属性也都是来自 <code>wrapper</code> ，比如 <code>doc</code> ， <code>source</code> 等等。</p>
<p>使用标准库里的 functools.wraps ，可以基本解决这个问题。</p>
<pre><code class="language-python">from functools import wrapsdef logging(func):
   @wraps(func)
   def wrapper(*args, **kwargs):
       &quot;&quot;&quot;print log before a function.&quot;&quot;&quot;
       print &quot;[DEBUG] {}: enter {}()&quot;.format(datetime.now(), func.__name__)        
       return func(*args, **kwargs)    
   return wrapper

@logging
def say(something):
   &quot;&quot;&quot;say something&quot;&quot;&quot;

   print &quot;say {}!&quot;.format(something)
   print say.__name__  # say
   print say.__doc__  # say something
</code></pre>
<p>看上去不错！主要问题解决了，但其实还不太完美。因为函数的签名和源码还是拿不到的。</p>
<pre><code class="language-python">import inspect
print inspect.getargspec(say)  # failed
print inspect.getsource(say)  # failed
</code></pre>
<p>如果要彻底解决这个问题可以借用第三方包，比如 <code>wrapt</code> 。后文有介绍。</p>
<h2 id="staticmethod-classmethod">不能装饰@staticmethod 或者 @classmethod<a class="headerlink" href="#staticmethod-classmethod" title="Permanent link">&para;</a></h2>
<p>当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。</p>
<pre><code class="language-python">class Car(object):

   def __init__(self, model):
       self.model = model    

   @logging  # 装饰实例方法，OK
   def run(self):
       print &quot;{} is running!&quot;.format(self.model)    

   @logging  # 装饰静态方法，Failed
   @staticmethod
   def check_model_for(obj):
       if isinstance(obj, Car):            
           print &quot;The model of your car is {}&quot;.format(obj.model)        
       else:            
           print &quot;{} is not a car!&quot;.format(obj)     
&quot;&quot;&quot;
Traceback (most recent call last):
...
 File &quot;example_4.py&quot;, line 10, in logging

   @wraps(func)
 File &quot;C:\Python27\lib\functools.py&quot;, line 33, in update_wrapper

   setattr(wrapper, attr, getattr(wrapped, attr))
AttributeError: 'staticmethod' object has no attribute '__module__'

&quot;&quot;&quot;
</code></pre>
<p>前面已经解释了 <code>@ staticmethod</code> 这个装饰器，其实它返回的并不是一个 <code>callable</code> 对象，而是一个 <code>staticmethod</code> 对象，那么它是不符合装饰器要求的（比如传入一个 callable 对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在 <code>@ staticmethod</code> 之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个 <code>@ staticmethod</code> 是不会出问题的。</p>
<pre><code class="language-python">class Car(object):
   def __init__(self, model):
       self.model = model    

   @staticmethod
   @logging  
   def check_model_for(obj):
       pass
</code></pre>
<h2 id="_10">如何优化你的装饰器<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h2>
<p>嵌套的装饰函数不太直观，我们可以使用第三方包类改进这样的情况，让装饰器函数可读性更好。</p>
<h3 id="decoratorpy">decorator.py<a class="headerlink" href="#decoratorpy" title="Permanent link">&para;</a></h3>
<p><code>decorator.py</code>是一个非常简单的装饰器加强包。你可以很直观的先定义包装函数 <code>wrapper ()</code> ，再使用 <code>decorate ( func , wrapper )</code> 方法就可以完成一个装饰器。</p>
<pre><code class="language-python">from decorator import decorate
def wrapper(func, *args, **kwargs):
   &quot;&quot;&quot;print log before a function.&quot;&quot;&quot;
   print &quot;[DEBUG] {}: enter {}()&quot;.format(datetime.now(), func.__name__)    
   return func(*args, **kwargs)

def logging(func):
   return decorate(func, wrapper)  # 用wrapper装饰func
</code></pre>
<p>你也可以使用它自带的 <code>@ decorator</code> 装饰器来完成你的装饰器。</p>
<pre><code class="language-python">from decorator import decorator
@decorator
def logging(func, *args, **kwargs):
   print &quot;[DEBUG] {}: enter {}()&quot;.format(datetime.now(), func.__name__)    
   return func(*args, **kwargs)
</code></pre>
<p><code>decorator.py</code> 实现的装饰器能完整保留原函数的 <code>name</code> ， <code>doc</code> 和 <code>args</code> ，唯一有问题的就是 <code>inspect.getsource ( func )</code> 返回的还是装饰器的源代码，你需要改成 <code>inspect.getsource ( func.__wrapped__ )</code> 。</p>
<h3 id="wrapt">wrapt<a class="headerlink" href="#wrapt" title="Permanent link">&para;</a></h3>
<p><code>wrapt</code>是一个功能非常完善的包，用于实现各种你想到或者你没想到的装饰器。使用 wrapt 实现的装饰器你不需要担心之前 inspect 中遇到的所有问题，因为它都帮你处理了，甚至 <code>inspect.getsource ( func )</code> 也准确无误。</p>
<pre><code class="language-python">import wrapt# without argument in decorator

@wrapt.decorator
def logging(wrapped, instance, args, kwargs):  # instance is must
   print &quot;[DEBUG]: enter {}()&quot;.format(wrapped.__name__)    
   return wrapped(*args, **kwargs)

@logging
def say(something): pass
</code></pre>
<p>使用 <code>wrapt</code> 你只需要定义一个装饰器函数，但是函数签名是固定的，必须是 <code>( wrapped , instance, args, kwargs )</code> ，注意第二个参数 <code>instance</code> 是必须的，就算你不用它。当装饰器装饰在不同位置时它将得到不同的值，比如装饰在类实例方法时你可以拿到这个类实例。根据 <code>instance</code> 的值你能够更加灵活的调整你的装饰器。另外， <code>args</code> 和 <code>kwargs</code> 也是固定的，注意前面没有星号。在装饰器内部调用原函数时才带星号。</p>
<p>如果你需要使用 wrapt 写一个带参数的装饰器，可以这样写。</p>
<pre><code class="language-python">def logging(level):
   @wrapt.decorator
   def wrapper(wrapped, instance, args, kwargs):
       print &quot;[{}]: enter {}()&quot;.format(level, wrapped.__name__)        
       return wrapped(*args, **kwargs)    
   return wrapper@logging(level=&quot;INFO&quot;)

def do(work): pass
</code></pre>
<p>关于 wrapt 的使用，建议查阅官方文档，在此不在赘述。
http://wrapt.readthedocs.io/en/latest/quick-start.html</p>
<h2 id="_11">小结<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<p>Python 的装饰器和 Java 的注解（ Annotation ）并不是同一回事，和 C# 中的特性（ Attribute ）也不一样，完全是两个概念。</p>
<p>装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为 <code>wrapper ()</code> ，意义在于包装。函数只有在被调用时才会发挥其作用。比如 <code>@ logging</code> 装饰器可以在函数执行时额外输出日志， <code>@ cache</code> 装饰过的函数可以缓存计算结果等等。</p>
<p>而注解和特性则是对目标函数或对象添加一些属性，相当于将其分类。这些属性可以通过反射拿到，在程序运行时对不同的特性函数或对象加以干预。比如带有 <code>Setup</code> 的函数就当成准备步骤执行，或者找到所有带有 <code>TestMethod</code> 的函数依次执行等等。</p>
<p>至此我所了解的装饰器已经讲完，但是还有一些内容没有提到，比如装饰类的装饰器。有机会再补充。谢谢观看。</p>
<blockquote>
<p>本文源码 &lt;https://github.com/tobyqin/python_decorator</p>
</blockquote>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../python-config/" class="btn btn-neutral float-left" title="Python程序配置文件管理"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../python-dunder/" class="btn btn-neutral float-right" title="5种下划线">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright © 2022 - 2023 - lyvivian0077</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../python-config/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../python-dunder/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
