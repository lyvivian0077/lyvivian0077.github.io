<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Bash编程超详细语法总结 - 总有刁民想要害朕</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Bash\u7f16\u7a0b\u8d85\u8be6\u7ec6\u8bed\u6cd5\u603b\u7ed3";
        var mkdocs_page_input_path = "Bash\u7f16\u7a0b\u8d85\u8be6\u7ec6\u8bed\u6cd5\u603b\u7ed3.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QXRGWVKZW2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QXRGWVKZW2');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 总有刁民想要害朕
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">ansbile</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile/">ansbileオプション</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile_async/">ansbile_async</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../awk/">awk</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../MB-MiB%E7%9A%84%E5%8C%BA%E5%88%AB/">MB_MiB的区别</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">MegaRAID</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../megacli/">megacli</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../megaraid/">megaraid</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MySQL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Explain详解与索引最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql/">Mysql参数优化</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql-table/">MySQL-table</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql%E3%82%92%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/">MySQLビルド</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python Tips</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../python-styleguide/">Python风格规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-config/">Python程序配置文件管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-decorator/">装饰器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-dunder/">5种下划线</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-function/">传入参数的几种方法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python/">非常规的技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-mysql/">操作mysql基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python-Re-%E6%A8%A1%E5%9D%97%E8%B6%85%E5%85%A8%E8%A7%A3%E8%AF%BB/">Re 模块</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/">字符串拼接总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C/">代码并行</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Regular-Expression/">正規表現</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../taged-VLAN%E3%81%A8untagedVLAN%E3%81%AE%E9%81%95%E3%81%84/">タグVLAN</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sar/">sar</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Bash编程超详细语法总结</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#bash_1">bash变量类别</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bash_2">bash的配置文件：</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">功能：设定本地变量，定义命令别名</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bash_3">bash编程之编写格式及执行方式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bash_4">bash之算数运算与逻辑运算</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bash_5">bash编程之条件测试语句</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#bash_6">bash条件测试</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bash_7">bash编程之循环语句</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bash_8">bash编程之函数</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">语法结构：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bash_9">bash编程之信号捕捉</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bash_10">bash编程之数组</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bash_11">bash编程之字符串操作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#patternglobbing">pattern可以使用globbing中的元字符：* ？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">变量赋值操作：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#mktemp">mktemp命令：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#install">install命令:</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../iptables/">iptables</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../linux-lvm/">linux-lvm</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos7-set-kernel/">centos7-set-kernel</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos-network-device-naming/">centos-network-device-naming</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-Performance/">Linux Performance</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">Linux-shell-逻辑运算符-逻辑表达式详解</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">LVM逻辑卷基本概念及LVM的工作原理</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../macOS%E8%BD%AF%E4%BB%B6%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E6%9B%B4%E6%96%B010-15/">macOS软件编译时找不到头文件解决方法[更新10.15]</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ubnt/">ubnt</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vim/">VIM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">总有刁民想要害朕</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>Bash编程超详细语法总结</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <ul>
<li><a href="https://mp.weixin.qq.com/s/r5KNvm90qYnnNOL3TAVXJA">原文</a></li>
</ul>
<p>在Linux学习过程中，我们无可避免的会碰到一个既让人喜欢，又令人头疼的神奇的东西——bash编程，即shell脚本。
那么什么是shell脚本呢？shell是一个命令语言解释器，而shell脚本则是Linux命令的集合，
按照预设的顺序依次解释执行，来完成特定的、较复杂的系统管理任务，类似于Windows中的批处理文件。
本文带来的是bash编程的基础语法讲解。</p>
<h2 id="bash">bash编程之变量<a class="headerlink" href="#bash" title="Permanent link">&para;</a></h2>
<h3 id="bash_1">bash变量类别<a class="headerlink" href="#bash_1" title="Permanent link">&para;</a></h3>
<p><strong>本地变量</strong> : 只对当前shell进程有效的变量，对其它shell进程无效，包当前shell进程的子进程</p>
<pre><code>VAR_NAME=VALUE
</code></pre>
<p><strong>变量赋值</strong> : 向变量的存储空间保存数据</p>
<p><strong>变量引用</strong> : ${VAR_NAME} </p>
<pre><code>&quot;&quot;:弱引用，里面的变量会被替换
'':强引用，里面的所有字符都是字面量，直接输出
</code></pre>
<p><strong>环境变量</strong> : 对当前shell进程及其子shell有效，对其它的shell进程无效</p>
<pre><code>定义：export VAR_NAME=VALUE
导出：export VAR_NAME
撤消变量：unset VAR_NAME
只读变量：readonly VAR_NAME
</code></pre>
<p><strong>局部变量</strong> : 对shell脚本中某代码片断有效，通常用于函数本地</p>
<pre><code>local VAR_NAME=VALUE
</code></pre>
<p><strong>位置变量</strong> : 用来接受变量指定位置的参数</p>
<pre><code>$1,$2...,${10}
</code></pre>
<p><strong>特殊变量</strong> : shell对一些参数做特殊处理,这些参数只能被引用而不能被赋值</p>
<pre><code>$#  传递到脚本的参数个数
$*  显示所有向脚本传递的参数                  #与位置变量不同，此选项参数可超过9个
$$  获取当前shell的进程号
$!  执行上一个指令的进程号
$?  获取执行的上一个指令的返回值              #0为执行成功，非零为执行失败
$-  显示shell使用的当前选项，与set命令功能相同
$@  与$*相同，但是使用时加引号，并在引号中返回每个参数
</code></pre>
<p><strong>查看变量</strong> :</p>
<pre><code>set：查看当前shell进程中的所有变量
export, printenv, env：查看当前shell进程中的所有环境变量
</code></pre>
<p><strong>变量命名</strong> :
  1. 不能使用程序中的关键字（保留字）
  2. 只能使用数字、字母和下划线，且不能以数字开头
  3. 要见名知义</p>
<p><strong>变量类型</strong> :</p>
<pre><code>数值型：精确数值(整数)，近似数值（浮点型）
字符型：char,string
布尔型：true, false
</code></pre>
<p><strong>类型转换</strong> :</p>
<pre><code>显式转换
隐式转换
</code></pre>
<h3 id="bash_2">bash的配置文件：<a class="headerlink" href="#bash_2" title="Permanent link">&para;</a></h3>
<h4 id="_1">功能：设定本地变量，定义命令别名<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<ul>
<li>profile类：为交互式登录的用户提供配置</li>
</ul>
<pre><code>全局：/etc/profile、/etc/profile.d/*.sh
用户：~/.bash_profile
</code></pre>
<ul>
<li>bashrc类：为非交互式的用户提供配置</li>
</ul>
<pre><code>全局：/etc/bashrc
用户：~/.bashrc
</code></pre>
<h4 id="bash_3">bash编程之编写格式及执行方式<a class="headerlink" href="#bash_3" title="Permanent link">&para;</a></h4>
<ul>
<li>编写格式：shell脚本第一行必须顶格写，用shebang定义指定的解释器来解释该脚本。</li>
</ul>
<pre><code>#!/bin/bash       #!即为shebang
# 其它的以#开头的行均为注释，会被解释器忽略，可用来注释脚本用途及版本，方便使用管理。
</code></pre>
<ul>
<li>执行方式：bash编程属于面向过程编程，执行方式如下：</li>
</ul>
<pre><code>顺序执行：按命令先后顺寻依次执行
选择执行：测试条件，可能会多个测试条件，某条件满足时，则执行对应的分支
循环执行：将同一段代码反复执行多次，因此，循环必须有退出条件；否则，则陷入死循环
</code></pre>
<ul>
<li>bash执行选项：</li>
</ul>
<pre><code>bash -n SHELLNAME  #语法测试，测试是否存在语法错误
bash -x SHELLNAME  #模拟单步执行，显示每一步执行过程
</code></pre>
<h4 id="bash_4">bash之算数运算与逻辑运算<a class="headerlink" href="#bash_4" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>算数运算</p>
</li>
<li>
<p>定义整型变量：</p>
</li>
</ul>
<pre><code>let VAR_NAME=INTEGER_VALUE            #例如：let a=3
declare -i VAR_NAME=INTEGER_VALUE     #declare -i a=3
</code></pre>
<ul>
<li>实现算术运算的方式：</li>
</ul>
<pre><code>let VAR_NAME=ARITHMATIC_EXPRESSION
VAR_NAME=$[ARITHMATIC_EXRESSION]
VAR_NAME=$((EXPRESSION))
VAR_NAME=$(expr $num1 + $num2)
</code></pre>
<ul>
<li>算术运算符：</li>
</ul>
<pre><code>+：加法
-：减法
*：乘法
/：整除
%：取余数
**：乘幂
</code></pre>
<blockquote>
<p>注意：即使没有定义为整型变量，字符型的数字依然可以参与算术运算，bash会执行变量类型的隐式类型转换。
  - 逻辑运算</p>
</blockquote>
<pre><code>布尔运算：真，假
与运算：真 &amp;&amp; 真 = 真
        真 &amp;&amp; 假 = 假
        假 &amp;&amp; 真 = 假
        假 &amp;&amp; 假 = 假
或运算：真 || 真 = 真
  真 || 假 = 真
  假 || 真 = 真
  假 || 假 = 假
非运算：！真=假
        ！假=真
</code></pre>
<h3 id="bash_5">bash编程之条件测试语句<a class="headerlink" href="#bash_5" title="Permanent link">&para;</a></h3>
<h4 id="bash_6">bash条件测试<a class="headerlink" href="#bash_6" title="Permanent link">&para;</a></h4>
<p><strong>整型测试</strong>：整数比较</p>
<pre><code>例如 [ $num1 -gt $num2 ]

-gt: 大于则为真
-lt: 小于则为真
-ge: 大于等于则为真
-le: 小于等于则为真
-eq: 等于则为真
-ne: 不等于则为真
</code></pre>
<p><strong>字符测试</strong>：字符串比较</p>
<pre><code>双目：
例如[[ &quot;$str1&quot; &gt; &quot;$str2&quot; ]]

&gt;: 大于则为真
&lt;: 小于则为真
&gt;=：大于等于则为真
&lt;=：小于等于则为真
==：等于则为真
!=：不等于则为真


单目：
-n String: 是否不空，不空则为真，空则为假
-z String: 是否为空，空则为真，不空则假

文件测试：判断文件的存在性及属性等

-a FILE：存在则为真；否则则为假；
-e FILE: 存在则为真；否则则为假；
-f FILE: 存在并且为普通文件，则为真；否则为假；
-d FILE: 存在并且为目录文件，则为真；否则为假；
-L/-h FILE: 存在并且为符号链接文件，则为真；否则为假；
-b: 存在并且为块设备，则为真；否则为假；
-c: 存在并且为字符设备，则为真；否则为假
-S: 存在并且为套接字文件，则为真；否则为假
-p: 存在并且为命名管道，则为真；否则为假
-s FILE: 存在并且为非空文件则为值，否则为假；
-r FILE：文件可读为真，否则为假
-w FILE：文件可写为真，否则为假
-x FILE：文件可执行为真，否则为假
file1 -nt file2: file1的mtime新于file2则为真，否则为假；
file1 -ot file2：file1的mtime旧于file2则为真，否则为假；

组合条件测试：在多个条件间实现逻辑运算

与：[ condition1 -a condition2 ]
  condition1 &amp;&amp; condition2
或：[ condition1 -o condition2 ]
  condition1 || condition2
非：[ -not condition ]
  ! condition
与：COMMAND1 &amp;&amp; COMMAND2
COMMAND1如果为假，则COMMAND2不执行
或：COMMAND1 || COMMAND2
COMMAND1如果为真，则COMMAND2不执行
非：! COMMAND
</code></pre>
<p><strong>条件测试之if语句</strong></p>
<pre><code>1、if语句之单分支
语句结构：
if 测试条件;then
   选择分支
fi
表示条件测试状态返回值为值，则执行选择分支
例：写一个脚本，接受一个参数，这个参数是用户名；如果此用户不存在，则创建该用户；

#！/bin/bash
if ! id $1 &amp;&gt; /dev/null;then
  useradd $1
fi

2、if语句之双分支
语句结构：
if 测试条件;then
   选择分支1
else
   选择分支2
fi

两个分支仅执行其中之一
例：通过命令行给定一个文件路径，而后判断：如果此文件中存在空白行，则显示其空白行的总数；否则，则显示无空白行；
#！/bin/bash
if grep &quot;^[[:space]]*$&quot; $1 &amp;&gt; /dev/null; then
  echo &quot;$1 has $(grep &quot;^[[:space]]*$&quot; $1 | wc -l) blank lines.&quot;
else
  echo &quot;No blank lines&quot;
fi

注意：如果把命令执行成功与否当作条件，则if语句后必须只跟命令本身，而不能引用。

3、if语句之多分支
语句结构：
if 条件1;then
     分支1
elif 条件2;then
     分支2
elif 条件3;then
     分支3
      ...
else
     分支n
fi

例：传递一个用户名给脚本：如果此用户的id号为0，则显示说这是管理员；如果此用户的id号大于等于500，则显示说这是普通用户；否则，则说这是系统用户。
#!/bin/bash
if [ $# -lt 1 ]; then
  echo &quot;Usage: `basename $0` username&quot;
  exit 1
fi
if ! id -u $1 &amp;&gt; /dev/null; then
  echo &quot;Usage: `basename $0` username&quot;
  echo &quot;No this user $1.&quot;
  exit 2
fi

if [ $(id -u $1) -eq 0 ]; then
  echo &quot;Admin&quot;
elif [ $(id -u $1) -ge 500 ]; then
  echo &quot;Common user.&quot;
else
  echo &quot;System user.&quot;
fi
</code></pre>
<p><strong>bash交互式编程</strong></p>
<pre><code>read [option] “prompt”-p:直接指定一个变量接受参数
-t timaout：指定等待接受参数的时间
-n:表示不换行

例：输入用户名，可返回其shell

#!/bin/bash
read -p &quot;Plz input a username: &quot; userName
if id $userName &amp;&gt; /dev/null; then
    echo &quot;The shell of $userName is `grep &quot;^$userName\&gt;&quot; /etc/passwd | cut -d: -f7`.&quot;
else
    echo &quot;No such user. stupid.&quot;
fi    
</code></pre>
<p><strong>条件测试之case语句</strong></p>
<pre><code>
case语句：有多个测试条件时，case语句会使得语法结构更明晰
语句结构：

case 变量引用 in
PATTERN1)
  分支1
;;
PATTERN2)
  分支2
;;
...
*)
  分支n
;;
esac
</code></pre>
<p><strong>PATTERN：类同于文件名通配机制，但支持使用|表示或者</strong></p>
<pre><code> a|b:  a或者b*：匹配任意长度的任意字符
?: 匹配任意单个字符
[]: 指定范围内的任意单个字符

例：写一个脚本，完成如下任务，其使用形式如下所示：
script.sh {start|stop|restart|status}

其中：如果参数为空，则显示帮助信息，并退出脚本；
如果参数为start，则创建空文件/var/lock/subsys/script，并显示“starting script successfully.”
如果参数为stop，则删除文件/var/lock/subsys/script，并显示“Stop script successfully.”
如果参数为restart，则删除文件/var/locksubsys/script并重新创建，而后显示“Restarting script successfully.”
如果参数为status，那么：如果文件/var/lock/subsys/script存在，则显示“Script is running…”，否则，则显示“Script is stopped.”

#!/bin/bash
file='/var/lock/subsys/script'
case $1 in
start)
  if [ -f $file ];then
  echo &quot;Script is running...&quot;
    exit 3
  else
  touch $file
  [ $? -eq 0 ] &amp;&amp; echo &quot;Starting script successfully.&quot;
  fi
  ;;
stop)
  if [ -f $file ];then
  rm -rf $file
  [ $? -eq 0 ] &amp;&amp; echo &quot;Stop script successfully.&quot;
  else
  echo &quot;Script is stopped...&quot;
  exit 4
  fi
  ;;
restart)
  if [ -f $file ];then
  rm -rf $file
  [ $? -eq 0 ] &amp;&amp; echo &quot;Stop script successfully&quot;
  else 
  echo &quot;Script is stopped...&quot;
  exit 5
  fi
  touch $file
  [ $? -eq 0 ] &amp;&amp; echo &quot;Starting script successfully&quot;
  ;;
status)
  if [ -f $file ];then
  echo &quot;Script is running...&quot;
  else
  echo &quot;Script is stopped.&quot;
  fi
  ;;
*)
  echo &quot;`basename $0` {start|stop|restart|status}&quot;
  exit 2
  ;;
 esac
</code></pre>
<h4 id="bash_7">bash编程之循环语句<a class="headerlink" href="#bash_7" title="Permanent link">&para;</a></h4>
<p><strong>循环之for循环</strong></p>
<pre><code>1、for语句格式一
语句结构：
for 变量名 in 列表; do
    循环体
done
列表：可包含一个或多个元素
循环体：依赖于调用变量来实现其变化
循环可嵌套
退出条件：遍历元素列表结束
例：求100以内所有正整数之和

#!/bin/bash
declare -i sum=0
for i in {1..100}; do
    let sum+=$i
done
echo $sum

2、for语句格式二
for ((初始条件;测试条件;修改表达式)); do
      循环体
done
先用初始条件和测试条件做判断，如果符合测试条件则执行循环体，再修改表达式，否则直接跳出循环。

例：求100以内所有正整数之和（for二实现）
#!/bin/bash
declare -i sum=0
for ((counter=1;$counter &lt;= 100; counter++)); do
  let sum+=$counter
done
echo $sum
</code></pre>
<p><strong>循环之while语句</strong></p>
<p>while适用于循环次数未知，或不便用for直接生成较大的列表时</p>
<pre><code>语句结构：
while 测试条件; do
  循环体
done
测试条件为真，进入循环；测试条件为假，退出循环
例1：求100以内所有偶数之和，要求使用取模方法
#!/bin/bash
declare -i counter=1
declare -i sum=0
while [ $counter -le 100 ]; do
  if [ $[$counter%2] -eq 0 ]; then
     let sum+=$counter
  fi
  let counter++
 done
echo $sum

例2：提示用户输入一个用户名，如果用户存在，就显示用户的ID号和shell；否则显示用户不存在；显示完成之后不退出，再次重复前面的操作，直到用户输入q或quit为止
#!/bin/bash
read -p &quot;Plz enter a username: &quot; userName
while [ &quot;$userName&quot; != 'q' -a &quot;$userName&quot; != 'quit' ]; do
  if id $userName &amp;&gt; /dev/null; then
     grep &quot;^$userName\&gt;&quot; /etc/passwd | cut -d: -f3,7
  else
    echo &quot;No such user.&quot;
  fi
read -p &quot;Plz enter a username again: &quot; userName
done

while特殊用法：遍历文本文件
语句结构：
while read 变量名; do
  循环体
done &lt; /path/to/somefile
变量名，每循环一次，记忆了文件中一行文本

例：显示ID号为偶数，且ID号同GID的用户的用户名、ID和SHELL
while read line; do
  userID=`echo $line | cut -d: -f3`
  groupID=`echo $line | cut -d: -f4`
  if [ $[$userID%2] -eq 0 -a $userID -eq $groupID ]; then
     echo $line | cut -d: -f1,3,7
  fi
done &lt; /etc/passwd
</code></pre>
<p><strong>循环之until语句</strong></p>
<pre><code>语句结构：
until 测试条件; do
      循环体
done
测试条件为假，进入循环；测试条件为真，退出循环

例：求100以内所有偶数之和，要求使用取模方法（until实现）

#!/bin/bash
declare -i counter=1
declare -i sum=0
until [ $counter -gt 100 ]; do
  if [ $[$counter%2] -eq 0 ]; then
     let sum+=$counter
  fi
  let counter++
done
echo $sum
例：提示用户输入一个用户名，如果用户存在，就显示用户的ID号和shell；否则显示用户不存在；显示完成之后不退出，再次重复前面的操作，直到用户输入q或quit为止（until实现）


#!/bin/bash
read -p &quot;Plz enter a username: &quot; userName
until [ &quot;$userName&quot; = 'q' -a &quot;$userName&quot; = 'quit' ]; do
  if id $userName &amp;&gt; /dev/null; then
   grep &quot;^$userName\&gt;&quot; /etc/passwd | cut -d: -f3,7
else
echo &quot;No such user.&quot;
fi
read -p &quot;Plz enter a username again: &quot; userName
done
</code></pre>
<p><strong>循环之循环控制和shift</strong></p>
<pre><code>
循环控制命令：
break：提前退出循环
break [N]: 退出N层循环；N省略时表示退出break语句所在的循环
continue: 提前结束本轮循环，而直接进入下轮循环
continue [N]：提前第N层的循环的本轮循环，而直接进入下轮循环
</code></pre>
<p><strong>死循环：</strong></p>
<pre><code>
#while体while true; do
      循环体
done
#until体
until false; do
      循环体
done

例1：写一个脚本，判断给定的用户是否登录了当前系统
(1) 如果登录了，则脚本终止；
(2) 每5秒种，查看一次用户是否登录；
#!/bin/bash
while true; do
    who | grep &quot;gentoo&quot; &amp;&gt; /dev/null
    if [ $? -eq 0 ];then
break
    fi
    sleep 5
done
echo &quot;gentoo is logged.&quot;
</code></pre>
<p><strong>shift：</strong></p>
<pre><code>如果没有数字，只有shift 就是跳过一个参数获取下一个参数，如果加上数字，比如shift 2 ，跳过两个参数获取下一个参数。
例：写一个脚本，使用形式如下所示    
showifinfo.sh [-i INTERFACE|-a] [-v]
要求：
1、-i或-a不可同时使用，-i用于指定特定网卡接口，-a用于指定所有接口；
显示接口的ip地址
2、使用-v，则表示显示详细信息，显示接口的ip地址、子网掩码、广播地址；
3、默认表示仅使用-a选项;

#!/bin/bash
allinterface=0
ifflag=0
verbose=0
interface=0
if [ $# -eq 0 ];then
  ifconfig | grep &quot;inet addr:&quot; | awk '{print $2}'
fi
while [ $# -ge 1 ];do
  case $1 in 
-a)
 allinterface=1
 shift 1
  ;;
-i)
  ifflag=1
  interface=$2
  shift 2
  ;;
-v)
  verbose=1
  shift 1
  ;;
  *)
echo &quot;error option&quot;
exit 2
  ;;
  esac
done
if [ $allinterface -eq 1 ];then
  if [ $ifflag -eq 1 ];then
   echo &quot;command not found&quot;
    exit 5
  fi
  if [ $verbose -eq 1 ];then
    ifconfig | grep &quot;inet addr:&quot;
  else
    ifconfig | grep &quot;inet addr:&quot; | awk '{print $2}'
  fi
fi
if [ $ifflag -eq 1 ];then
  if [ $allinterface -eq 1 ];then
        echo &quot;command not found&quot;
        exit 5
  fi
 if [ $verbose -eq 1 ];then
    ifconfig $interface | grep &quot;inet addr:&quot;
  else
    ifconfig $interface | grep &quot;inet addr:&quot; | awk '{print $2}'
  fi
fi
</code></pre>
<h3 id="bash_8">bash编程之函数<a class="headerlink" href="#bash_8" title="Permanent link">&para;</a></h3>
<h4 id="_2">语法结构：<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<pre><code>
function F_NAME {    
   函数体
  }

  F_NAME() {
    函数体
  }
</code></pre>
<p>可调用：使用函数名，函数名出现的地方，会被自动替换为函数
函数的返回值：
函数的执行结果返回值：代码的输出
函数中使用打印语句：echo, printf
函数中调用的系统命令执行后返回的结果
执行状态返回值：
默认取决于函数体执行的最后一个命令状态结果
自定义退出状态码：return [0-255]</p>
<blockquote>
<p>注意：函数体运行时，一旦遇到return语句，函数即返回；</p>
</blockquote>
<p><strong>函数可以接受参数：</strong>
在函数体中调用函数参数的方式同脚本中调用脚本参数的方式：</p>
<pre><code>位置参数
$1, $2, …
$#, $*, $@
</code></pre>
<p>例：写一个脚本，完成如下功能(使用函数)：</p>
<p>1、提示用户输入一个可执行命令；</p>
<p>2、获取这个命令所依赖的所有库文件(使用ldd命令)；</p>
<p>3、复制命令至/mnt/sysroot/对应的目录中</p>
<p>解释：假设，如果复制的是cat命令，其可执行程序的路径是/bin/cat，那么就要将/bin/cat复到/mnt/sysroot/bin/目录中，如果复制的是useradd命令，而useradd的可执行文件路径为/usr/sbin/useradd，那么就要将其复制到/mnt/sysroot/usr/sbin/目录中；</p>
<p>4、复制各库文件至/mnt/sysroot/对应的目录中；</p>
<pre><code>#!/bin/bash
target=/mnt/sysroot/
[ -d $target ] || mkdir $target
preCommand() {
    if which $1 &amp;&gt; /dev/null; then
  commandPath=`which --skip-alias $1`
  return 0
    else
  echo &quot;No such command.&quot;
  return 1
    fi
}

commandCopy() {
    commandDir=`dirname $1`
    [ -d ${target}${commandDir} ] || mkdir -p ${target}${commandDir}
    [ -f ${target}${commandPath} ] || cp $1 ${target}${commandDir}
}

libCopy() {
    for lib in `ldd $1 | egrep -o &quot;/[^[:space:]]+&quot;`; do
libDir=`dirname $lib`
[ -d ${target}${libDir} ] || mkdir -p ${target}${libDir}
[ -f ${target}${lib} ] || cp $lib ${target}${libDir}
    done
} 
read -p &quot;Plz enter a command: &quot; command

until [ &quot;$command&quot; == 'quit' ]; do

  if preCommand $command &amp;&gt; /dev/null; then
    commandCopy $commandPath
    libCopy $commandPath
  fi

  read -p &quot;Plz enter a command: &quot; command
done
</code></pre>
<h4 id="bash_9">bash编程之信号捕捉<a class="headerlink" href="#bash_9" title="Permanent link">&para;</a></h4>
<p>trap命令用于在shell程序中捕捉到信号，之后可以有三种反应方式：</p>
<ul>
<li>(1)执行一段程序来处理这一信号</li>
<li>(2)接受信号的默认操作</li>
<li>(3)忽视这一信号</li>
</ul>
<p>trap对上面三种方式提供了三种基本形式：</p>
<p>第一种形式的trap命令在shell接收到signal list清单中数值相同的信号时，将执行双引号中的命令串。</p>
<pre><code>trap 'commands' signal-list
trap &quot;commands&quot; signal-list
</code></pre>
<p>第二种形式的trap命令恢复信号的默认操作：</p>
<pre><code>trap signal-list
</code></pre>
<p>第三种形式的trap命令允许忽视信号：</p>
<pre><code>trap &quot; &quot; signal-list
trap 'COMMAND' SIGINT（表示关闭进程）
</code></pre>
<p>例：写一个脚本，能够ping探测指定网络内的所有主机是否在线,当没有执行完时可接收ctrl+c命令退出。</p>
<pre><code>
#!/bin/bash
quitScript() {
   echo &quot;Quit...&quot;
}    
trap 'quitScript; exit 5' SIGINT

cnetPing() {
  for i in {1..254}; do
    if ping -c 1 -W 1 $1.$i &amp;&gt; /dev/null; then
      echo &quot;$1.$i is up.&quot;
     else
      echo &quot;$1.$i is down.&quot;
    fi
    done
}

bnetPing() {
  for j in {0..255}; do
    cnetPing $1.$j 
  done
}
anetPing() {
for m in {0..255}; do
bnetPing $1.$m
done
}

netType=`echo $1 | cut -d&quot;.&quot; -f1`

if [ $netType -ge 1 -a $netType -le 126 ]; then
anetPing $netType
elif [ $netType -ge 128 -a $netType -le 191 ]; then
bnetPing $(echo $1 | cut -d'.' -f1,2)
elif [ $netType -ge 192 -a $netType -le 223 ]; then
cnetPing $(echo $1 | cut -d'.' -f1-3)
else
echo &quot;Wrong&quot;
exit 2
fi
</code></pre>
<h3 id="bash_10">bash编程之数组<a class="headerlink" href="#bash_10" title="Permanent link">&para;</a></h3>
<p><strong>数组</strong>：连续的多个独立内存空间，每个内存空间相当于一个变量
<strong>数组元素</strong>：数组名+索引（从0开始编号）
<strong>索引的表示方式</strong>：a[0], a[1]
<strong>声明数组</strong>：</p>
<pre><code>declare -a ARRAR_NAME
</code></pre>
<p><strong>关联数组</strong>：</p>
<pre><code>declare -A ARRAY_NAME
</code></pre>
<p>支持稀疏格式：仅一维数组  </p>
<p>数组元素的赋值：</p>
<p>(1) 一次只赋值一个元素</p>
<pre><code>a[0]=$RANDOM
</code></pre>
<p>(2) 一次赋值全部元素</p>
<pre><code>a=(red blue yellow green)
</code></pre>
<p>(3) 指定索引进行赋值</p>
<pre><code>a=([0]=green [3]=red [2]=blue [6]=yellow)
</code></pre>
<p>(4) 用户输入</p>
<pre><code>read -a ARRAY
</code></pre>
<p><strong>数组的访问</strong>：
<strong>用索引访问</strong>：</p>
<pre><code>ARRAY[index]
</code></pre>
<p><strong>数组的长度</strong>：</p>
<pre><code>${#ARRAY[*]}
${#ARRAY[@]}
</code></pre>
<p>例：写一个脚本，生成10个随机数，保存至数组中；而后显示数组下标为偶数的元素</p>
<pre><code>#！/bin/bash
for i in {0..9}; do
    rand[$i]=$RANDOM
    [ $[$i%2] -eq 0 ] &amp;&amp; echo &quot;$i:${rand[$i]}&quot;
done
</code></pre>
<p><strong>从数组中挑选某元素</strong>:</p>
<pre><code>${ARRAY[@]:offset:number}
</code></pre>
<p><strong>切片</strong>：</p>
<pre><code>offset: 偏移的元素个数
number: 取出的元素的个数
${ARRAY[@]:offset}：取出偏移量后的所有元素
${ARRAY[@]}: 取出所有元素
</code></pre>
<p><strong>数组复制</strong>：要使用${ARRAY[@]}</p>
<pre><code>$@: 每个参数是一个独立的串
$*: 所有参数是一个串
</code></pre>
<p><strong>向数组中追加元素</strong>：非稀疏格式</p>
<pre><code>week, 
week[${#week[@]}]
</code></pre>
<p><strong>从数组中删除元素</strong>：</p>
<pre><code>unset ARRAY[index]
</code></pre>
<p>例：复制一个数组中下标为偶数的元素至一个新数组中</p>
<pre><code>#!/bin/bash
declare -a mylogs
logs=(/var/log/*.log)
echo ${logs[@]}
for i in `seq 0 ${#logs[@]}`; do
  if [ $[$i%2] -eq 0 ];then
    index=${#mylogs[@]}
     mylogs[$index]=${logs[$i]}
  fi
done
echo ${mylogs[@]}
</code></pre>
<p>例2：生成10个随机数，升序排序</p>
<pre><code>
#!/bin/bash
for((i=0;i&lt;10;i++))
do
  rnd[$i]=$RANDOM
done
echo -e &quot;total=${#rnd[@]}\n${rnd[@]}\nBegin to sort&quot;
for((i=9;i&gt;=1;i--))
do
        for((j=0;j&lt;i;j++))
  do
  if [ ${rnd[$j]} -gt ${rnd[$[$j+1]]} ] ;then
    swapValue=${rnd[$j]}
    rnd[$j]=${rnd[$[$j+1]]}
    rnd[$[$j+1]]=$swapValue
  fi
  done
done
echo ${rnd[@]}
</code></pre>
<p>例3：打印九九乘法表</p>
<pre><code>#!/bin/bashfor((i=1;i&lt;=9;i++))
do 
strLine=&quot;&quot;
  for((j=1;i&lt;=9;j++))
  do
    strLine=$strLine&quot;$i*$j=&quot;$[$i*$j]&quot;\t&quot;
    [ $i -eq $j ] &amp;&amp; echo -e $strLine &amp;&amp; break
  done
done
</code></pre>
<h3 id="bash_11">bash编程之字符串操作<a class="headerlink" href="#bash_11" title="Permanent link">&para;</a></h3>
<p><strong>字符串切片</strong>：</p>
<pre><code>${string:offset:length}
[root@scholar scripts]# string='hello word'
[root@scholar scripts]# echo ${string:2:4}
llo

取尾部的指定个数的字符：
${string: -length}
[root@scholar scripts]# echo ${string: -2}
rd

</code></pre>
<p><strong>取子串</strong>：基于模式</p>
<ul>
<li><code>${variable#*word}</code>：在variable中存储字串上，自左而右，查找第一次出现word，删除字符开始至此word处的所有内容；</li>
<li>$<code>{variable##*word}</code>：在variable中存储字串上，自左而右，查找最后一次出现word，删除字符开始至此word处的所有内容；
  <code>file='/var/log/messages'
${file#*/}: 返回的结果是var/log/messages
${file##*/}: 返回messages</code></li>
<li><code>${variable%word*}</code>: 在variable中存储字串上，自右而左，查找第一次出现word，删除此word处至字串尾部的所有内容；</li>
<li><code>${variable%%world*}</code>:在variable中存储字串上，自右而左，查找最后一次出现word，删除此word处至字串尾部的所有内容；</li>
</ul>
<pre><code>file='/var/log/messages'
${file%*/}: 返回的结果是/var/log
${file%%*/}: 返回结果为空

例：url=&quot;http://www.redhat.com:80&quot;
取端口：${url##*:}
取协议：${url%%:*}
</code></pre>
<p><strong>查找替换</strong>：</p>
<ul>
<li><code>${variable/pattern/substi}</code>: 替换第一次出现</li>
</ul>
<pre><code>#userinfo=`tail -1 /etc/passwd
#echo $userinfo
scholar:x:500:500:scholar:/home/scholar:/bin/bash
#echo ${userinfo/scholar/redhat}
redhat:x:500:500:scholar:/home/scholar:/bin/bash
</code></pre>
<ul>
<li><code>${variable//pattern/substi}</code>：替换所有的出现</li>
</ul>
<pre><code>#echo ${userinfo//scholar/redhat}
redhat:x:500:500:redhat:/home/redhat:/bin/bash
</code></pre>
<ul>
<li><code>${variable/#pattern/substi}</code>：替换行首被pattern匹配到的内容</li>
</ul>
<pre><code>#echo ${userinfo/#scholar/redhat}
redhat:x:500:500:scholar:/home/scholar:/bin/bash
</code></pre>
<ul>
<li><code>${variable/%pattern/substi}</code>：替换行尾被pattern匹配到的内容</li>
</ul>
<pre><code>#echo ${userinfo/%bash/redhat}
scholar:x:500:500:scholar:/home/scholar:/bin/redhat
</code></pre>
<h4 id="patternglobbing">pattern可以使用globbing中的元字符：<code>* ？</code><a class="headerlink" href="#patternglobbing" title="Permanent link">&para;</a></h4>
<p><strong>查找删除</strong>：</p>
<ul>
<li><code>${variable/pattern}</code>：删除第一次出现</li>
</ul>
<pre><code>#echo ${userinfo/scholar}
:x:500:500:scholar:/home/scholar:/bin/bash
</code></pre>
<ul>
<li><code>${variable//pattern}</code>：删除所有的出现</li>
</ul>
<pre><code>#echo ${userinfo//scholar}
:x:500:500::/home/:/bin/bash
</code></pre>
<ul>
<li><code>${variable/#pattern}</code>：删除行首被pattern匹配到的内容</li>
</ul>
<pre><code>#echo ${userinfo/#scholar}
:x:500:500:scholar:/home/scholar:/bin/bash
</code></pre>
<ul>
<li><code>${variable/%pattern}</code>：删除行尾被pattern匹配到的内容</li>
</ul>
<pre><code>#echo ${userinfo/%bash}
scholar:x:500:500:scholar:/home/scholar:/bin/
</code></pre>
<p><strong>大小写转换</strong>：</p>
<p>小–&gt;大：<code>${variable^^}</code></p>
<pre><code>#echo ${userinfo^^}
SCHOLAR:X:500:500:SCHOLAR:/HOME/SCHOLAR:/BIN/BASH
</code></pre>
<p>大–&gt;小：<code>${variable,,}</code></p>
<pre><code>#name=&quot;SCHOLAR&quot;
#echo ${name,,}
scholar
</code></pre>
<h4 id="_3">变量赋值操作：<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<ul>
<li><code>${variable:-string}</code>:variable为空或未设定，那么返回string，否则，返回variable变量的值；</li>
<li><code>${variable:=string}</code>:variable为空或未设定，则返回string，且将string赋值给变量variable，否则，返回variable的值；</li>
</ul>
<p>为脚本使用配置文件，并确保某变量有可用值的方式</p>
<p><code>variable=${variable:-default vaule}</code></p>
<p>写个脚本，配置etc目录；</p>
<ul>
<li>(1) 在配置文件中定义变量；</li>
<li>(2) 在脚本中source配置文件；</li>
</ul>
<pre><code>#!/bin/bash
[ -f /etc/sysconfig/network ] &amp;&amp; source /etc/network/network
[-z &quot;$HOSTAME&quot; -o &quot;$HOSTNAME&quot; = '(none)' ] || HOSTNAME ='localhost'
/bin/hostname $HOSTNAME
/bin/hostname
</code></pre>
<h4 id="mktemp">mktemp命令：<a class="headerlink" href="#mktemp" title="Permanent link">&para;</a></h4>
<p>mktemp [OPTIONS] filename.XXX</p>
<pre><code>-d: 创建临时目录
--tmpdir=/path/to/somewhere ：指定临时文件所在的目录

mktemp /tmp/tmp.XXX                    #XXX生成相同数量随机字符
mktemp --tmpdir=/var/tmp tmp.XXX       #指定目录创建临时文件
mktemp --tmpdir=/var/tmp -d tmp.XXX    #指定目录创建临时目录
</code></pre>
<h4 id="install">install命令:<a class="headerlink" href="#install" title="Permanent link">&para;</a></h4>
<p>install [OPTIONS] SOURCE DEST
install [OPTIONS] SOURCE… DIR
install [OPTIONS] -d DIR …</p>
<pre><code>增强型的复制命令：
-o OWNER
-g GROUP
-m MODE
-d : 创建目录

install /etc/fstab /tmp                 #复制文件到指定目录
install --mode=644 /etc/fstab /tmp/     #复制时指定权限
install --owner=scholar /etc/fstab /tmp #复制时指定属主
install --group=scholar /etc/fstab /tmp #复制时指定属组
install -d /tmp/install                 #创建目录
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../sar/" class="btn btn-neutral float-left" title="sar"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../iptables/" class="btn btn-neutral float-right" title="iptables">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright © 2022 - 2023 - lyvivian0077</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../sar/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../iptables/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
