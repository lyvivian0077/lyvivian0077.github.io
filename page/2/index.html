<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lyvivian0077.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="总有刁民想要害朕">
<meta property="og:url" content="https://lyvivian0077.github.io/page/2/index.html">
<meta property="og:site_name" content="总有刁民想要害朕">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="lyvivian">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lyvivian0077.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>总有刁民想要害朕</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">总有刁民想要害朕</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lyvivian</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/05/29/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/29/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Python字符串拼接总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-29 11:02:20" itemprop="dateCreated datePublished" datetime="2019-05-29T11:02:20+09:00">2019-05-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b350624f265da5954426713">原文</a></li>
</ul>
<h2 id="方法1：加号连接"><a href="#方法1：加号连接" class="headerlink" title="方法1：加号连接"></a>方法1：加号连接</h2><p>很多语言都支持使用加号连接字符串，Python也不例外，只需要简单的将2个或多个字符串相加就可以完成拼接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = a + b  <span class="comment"># 输出&#x27;Python私房菜&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法2：使用-操作符"><a href="#方法2：使用-操作符" class="headerlink" title="方法2：使用%操作符"></a>方法2：使用<code>%</code>操作符</h2><p>在Python 2.6以前，<code>%</code>操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;%s%s&#x27;</span> % (a, b)  <span class="comment"># 输出&#x27;Python私房菜&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法3：使用format方法"><a href="#方法3：使用format方法" class="headerlink" title="方法3：使用format方法"></a>方法3：使用<code>format</code>方法</h2><p>format方法是Python 2.6中出现的一种代替<code>%</code>操作符的字符串格式化方法，同样可以用来连接字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b)</span><br></pre></td></tr></table></figure>

<h2 id="方法4：使用f-string"><a href="#方法4：使用f-string" class="headerlink" title="方法4：使用f-string"></a>方法4：使用<code>f-string</code></h2><p>Python 3.6中引入了Formatted String Literals（字面量格式化字符串），简称f-string，<code>f-string</code>是<code>%</code>操作符和<code>format</code>方法的进化版，使用<code>f-string</code>连接字符串的方法和使用<code>%</code>操作符、<code>format</code>方法类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">f&#x27;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法5：使用str-join-方法"><a href="#方法5：使用str-join-方法" class="headerlink" title="方法5：使用str.join()方法"></a>方法5：使用<code>str.join()</code>方法</h2><p>字符串有一个内置方法<code>join</code>，其参数是一个序列类型，例如数组或者元组等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span> </span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;&#x27;</span>.join([a, b])</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连接少量字符串时<br>使用加号连接符在性能和可读性上都是明智的，如果对可读性有更高的要求，并且使用的Python 3.6以上版本，<code>f-string</code>也是一个非常好的选择，例如下面这种情况，<code>f-string</code>的可读性显然比加号连接好得多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">f&#x27;姓名：<span class="subst">&#123;name&#125;</span> 年龄：<span class="subst">&#123;age&#125;</span> 性别：<span class="subst">&#123;gender&#125;</span>&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;姓名：&#x27;</span> + name + <span class="string">&#x27;年龄：&#x27;</span> + age + <span class="string">&#x27;性别：&#x27;</span> + gender</span><br></pre></td></tr></table></figure>

<p><strong>连接大量字符串时</strong> <code>join</code>和<code>f-string</code>都是性能最好的选择，选择时依然取决于你使用的Python版本以及对可读性的要求，<code>f-string</code>在连接大量字符串时可读性并不一定好。<strong>切记不要使用加号连接，尤其是在for循环中。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/05/13/python-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/13/python-function/" class="post-title-link" itemprop="url">Python传入参数的几种方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-13 14:40:20" itemprop="dateCreated datePublished" datetime="2019-05-13T14:40:20+09:00">2019-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Python传入参数的几种方法"><a href="#Python传入参数的几种方法" class="headerlink" title="Python传入参数的几种方法"></a>Python传入参数的几种方法</h1><blockquote>
<p>Python传入参数的方法有：位置参数、默认参数、可变参数、关键字参数、和命名关键字参数、以及各种参数调用的组合</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Python唯一支持的参数传递方式是『共享传参』（call by sharing）</p>
<p>多数面向对象语言都采用这一模式，包括Ruby、Smalltalk和Java（Java的引用类型是这样，基本类型按值传递）</p>
<p>共享传参是指函数的各个形式参数获得实参中各个引用的副本；也就是说，函数内部的形参是实参的别名（alias）</p>
<p>这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换为另一个对象）</p>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>位置参数是最简单的传入参数的方式，在其它的语言中也常常被使用</p>
<h5 id="演示一："><a href="#演示一：" class="headerlink" title="演示一："></a>演示一：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">#3</span></span><br></pre></td></tr></table></figure>

<h5 id="演示二："><a href="#演示二：" class="headerlink" title="演示二："></a>演示二：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x, n</span>):</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>):</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        s *= n</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">power(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">#8</span></span><br></pre></td></tr></table></figure>


<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认参数就是在调用函数的时候使用一些包含默认值的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>):</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        s *= n</span><br><span class="line">    reutrn s</span><br><span class="line"></span><br><span class="line">power(<span class="number">3</span>)    <span class="comment">#9</span></span><br><span class="line">power(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">#8</span></span><br></pre></td></tr></table></figure>

<h3 id="定义默认参数要牢记一点：默认参数必须指向不变对象！"><a href="#定义默认参数要牢记一点：默认参数必须指向不变对象！" class="headerlink" title="定义默认参数要牢记一点：默认参数必须指向不变对象！"></a>定义默认参数要牢记一点：默认参数必须指向不变对象！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下这个函数如果被多次调用会在默认添加多个END字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">l = []</span>):</span></span><br><span class="line">    l.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为了避免这个问题，应该把传入的默认参数设置为不可变的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">l = <span class="literal">None</span></span>):</span></span><br><span class="line">    l = []</span><br><span class="line">    l.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>



<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数就是允许在调用参数的时候传入多个（≥0个）参数（类似于列表、字典）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传入一个列表，严格地说这不是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">l</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> l:</span><br><span class="line">        <span class="built_in">sum</span> += n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这才是可变参数，虽然在使用上和列表没有区别，但是参数nums接收到的是一个tuple（这些参数在传入时被自动组组装为一个元祖）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*nums</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="built_in">sum</span> += n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*my_ls)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可变参数允许传入0个～多个参数，而关键字参数允许在调用时以字典形式传入0个或多个参数（注意区别，一个是字典一个是列表）；在传递参数时用等号（=）连接键和值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用两个星号表示关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_info</span>(<span class="params">name, age, **kw</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name&quot;</span>, name, <span class="string">&quot;age&quot;</span>, age, <span class="string">&quot;other&quot;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_info(<span class="string">&quot;Xiaoming&quot;</span>, <span class="number">12</span>)</span><br><span class="line">name Xiaoming age <span class="number">12</span> other&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_info(<span class="string">&quot;Dahuang&quot;</span>, <span class="number">35</span>, city = <span class="string">&quot;Beijing&quot;</span>)</span><br><span class="line">name Dahuang age <span class="number">35</span> other &#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><p>命名关键字参数在关键字参数的基础上限制传入的的关键字的变量名</p>
<p>和普通关键字参数不同，命名关键字参数需要一个用来区分的分隔符*，它后面的参数被认为是命名关键字参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里星号分割符后面的city、job是命名关键字参数</span></span><br><span class="line">person_info(name, age, *, city, job):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_info(<span class="string">&quot;Alex&quot;</span>, <span class="number">17</span>, city = <span class="string">&quot;Beijing&quot;</span>, job = <span class="string">&quot;Engineer&quot;</span>)</span><br><span class="line">Alex <span class="number">17</span> Beijing Engineer    <span class="comment">#看来这里不再被自动组装为字典</span></span><br></pre></td></tr></table></figure>

<p>不过也有例外，如果参数中已经有一个可变参数的话，前面讲的星号分割符就不要写了（其实星号是写给Python解释器看的，如果一个星号也没有的话就无法区分命名关键字参数和位置参数了，而如果有一个星号即使来自变长参数就可以区分开来）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#args是变长参数，而city和job是命名关键字参数</span></span><br><span class="line">person_info(name, age, *args, city, job):</span><br><span class="line">    <span class="built_in">print</span>(name, age, args, city)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person_info(<span class="string">&quot;Liqiang&quot;</span>, <span class="number">43</span>, <span class="string">&quot;balabala&quot;</span>, city = <span class="string">&quot;Wuhan&quot;</span>, job = <span class="string">&quot;Coder&quot;</span>)</span><br><span class="line">Liqiang <span class="number">43</span> balabala Wuhan Coder</span><br></pre></td></tr></table></figure>

<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p>总结一下，在Python中一种可以使用5中传递参数的方式（位置参数、默认参数、变长参数、关键字参数、命名关键字参数）</p>
<p>注意，这些参数在书写时要遵循一定的顺序即：位置参数、默认参数、变长参数、关键字参数、命名关键字参数（和本文的行文顺序一致）</p>
<p>这里简单举两个栗子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a, <span class="string">&quot;b = &quot;</span>, b, <span class="string">&quot;args = &quot;</span>, args, <span class="string">&quot;kw = &quot;</span>,kw)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a, <span class="string">&quot;b = &quot;</span>, b, <span class="string">&quot;c = &quot;</span>, c, <span class="string">&quot;d = &quot;</span>, d, <span class="string">&quot;kw = &quot;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args =() kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x = <span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d = <span class="number">99</span>, ext = <span class="literal">None</span>)</span><br><span class="line">a = <span class="number">1</span> b =<span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>:<span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>关于Python参数传递，有以下几点提请注意：</p>
<ol>
<li><p>参数的传递是通过自动将对象赋值给本地变量名来实现的</p>
<ul>
<li>函数参数在实际中只是Python赋值的另一个实例而已，因为引用可以是以指针的形式来实现的，所有的参数实际上都是通过指针进行传递的，作为参数被传递的对象从来不自动拷贝</li>
</ul>
</li>
<li><p>在函数内部的参数名的赋值不会影响调用者 </p>
<ul>
<li>在函数运行时，在函数头部的参数名时一个新的、本地的变量名，这个变量名是在函数的本地作用域内的，函数参数名和调用者作用域中的变量是没有区别的</li>
</ul>
</li>
<li><p>改变函数的可变对象参数的值也许会对调用者有影响 </p>
<ul>
<li>换句话说，因为参数是简单地赋值给传入的对象，函数就能够就地改变传入的可变对象，因此其结果会影响调用者；可变参数对函数来说可以做输入和输出的</li>
</ul>
</li>
</ol>
<h5 id="Python的通过赋值进行传递的机制与C-的引用参数选项不完全相同，但是实际中，它与C语言的参数传递模型相当类似："><a href="#Python的通过赋值进行传递的机制与C-的引用参数选项不完全相同，但是实际中，它与C语言的参数传递模型相当类似：" class="headerlink" title="Python的通过赋值进行传递的机制与C++的引用参数选项不完全相同，但是实际中，它与C语言的参数传递模型相当类似："></a>Python的通过赋值进行传递的机制与C++的引用参数选项不完全相同，但是实际中，它与C语言的参数传递模型相当类似：</h5><ol>
<li><p>不可变参数“通过值”进行传递 </p>
<ul>
<li>像整数和字符串这样的对象是不可变对象，它们通过对象引用而不是拷贝进行传递的，但是因为无论如何都不可能在原处改变不可变对象，实际的效果就很像创建了一份拷贝</li>
</ul>
</li>
<li><p>可变对象是通过“指针”进行传递的 </p>
<ul>
<li>列表和字典这样的对象也是通过对象引用进行传递的，这一点与C语言使用指针传递数组很相似，可变对象能够在函数内部进行原处的改变，这一点和C数组很像</li>
</ul>
</li>
</ol>
<p><img src="/assets/python_code.jpg" alt="python_code"><br><img src="!--swig%EF%BF%BC11--" alt="python_res"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/04/17/Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/17/Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Linux-shell-逻辑运算符-逻辑表达式详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-17 11:08:20" itemprop="dateCreated datePublished" datetime="2019-04-17T11:08:20+09:00">2019-04-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux-shell-逻辑运算符、逻辑表达式详解"><a href="#Linux-shell-逻辑运算符、逻辑表达式详解" class="headerlink" title="Linux shell 逻辑运算符、逻辑表达式详解"></a>Linux shell 逻辑运算符、逻辑表达式详解</h1><ul>
<li>Google 开源项目风格指南<ul>
<li><a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/">https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/</a></li>
</ul>
</li>
</ul>
<h4 id="shell的逻辑运算符-涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。"><a href="#shell的逻辑运算符-涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。" class="headerlink" title="shell的逻辑运算符 涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。"></a>shell的逻辑运算符 涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。</h4><h3 id="一、逻辑运算符"><a href="#一、逻辑运算符" class="headerlink" title="一、逻辑运算符"></a>一、逻辑运算符</h3><h4 id="1、逻辑卷标表示意思"><a href="#1、逻辑卷标表示意思" class="headerlink" title="1、逻辑卷标表示意思"></a>1、逻辑卷标表示意思</h4><ol>
<li>关于档案与目录的侦测逻辑卷标 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-f 常用！侦测『档案』是否存在 eg: if [ -f filename ]</span><br><span class="line"></span><br><span class="line">-d 常用！侦测『目录』是否存在</span><br><span class="line"></span><br><span class="line">-b 侦测是否为一个『 block 档案』</span><br><span class="line"></span><br><span class="line">-c 侦测是否为一个『 character 档案』</span><br><span class="line"></span><br><span class="line">-S 侦测是否为一个『 socket 标签档案』</span><br><span class="line"></span><br><span class="line">-L 侦测是否为一个『 symbolic link 的档案』</span><br><span class="line"></span><br><span class="line">-e 侦测『某个东西』是否存在！</span><br></pre></td></tr></table></figure></li>
<li>关于程序的逻辑卷标 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-G 侦测是否由 GID 所执行的程序所拥有</span><br><span class="line"></span><br><span class="line">-O 侦测是否由 UID 所执行的程序所拥有</span><br><span class="line"></span><br><span class="line">-p 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）</span><br></pre></td></tr></table></figure></li>
<li>关于档案的属性侦测 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-r 侦测是否为可读的属性</span><br><span class="line"></span><br><span class="line">-w 侦测是否为可以写入的属性</span><br><span class="line"></span><br><span class="line">-x 侦测是否为可执行的属性</span><br><span class="line"></span><br><span class="line">-s 侦测是否为『非空白档案』</span><br><span class="line"></span><br><span class="line">-u 侦测是否具有『 SUID 』的属性</span><br><span class="line"></span><br><span class="line">-g 侦测是否具有『 SGID 』的属性</span><br><span class="line"></span><br><span class="line">-k 侦测是否具有『 sticky bit 』的属性</span><br></pre></td></tr></table></figure></li>
<li>两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-nt 第一个档案比第二个档案新</span><br><span class="line"></span><br><span class="line">-ot 第一个档案比第二个档案旧</span><br><span class="line"></span><br><span class="line">-ef 第一个档案与第二个档案为同一个档案（ link 之类的档案）</span><br></pre></td></tr></table></figure></li>
<li>逻辑的『和(and)』『或(or)』 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑的 AND 的意思</span><br><span class="line"></span><br><span class="line">|| 逻辑的 OR 的意思</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、运算符号-代表意义"><a href="#2、运算符号-代表意义" class="headerlink" title="2、运算符号 代表意义"></a>2、运算符号 代表意义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">=   等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串</span><br><span class="line"></span><br><span class="line">!=  不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串</span><br><span class="line"></span><br><span class="line">&lt;   小于 应用于：整型比较 在[] 中，不能使用 表示字符串</span><br><span class="line"></span><br><span class="line">&gt;   大于 应用于：整型比较 在[] 中，不能使用 表示字符串</span><br><span class="line"></span><br><span class="line">-eq 等于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-ne 不等于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-lt 小于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-gt 大于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-le 小于或等于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-ge 大于或等于 应用于：整型比较</span><br><span class="line"></span><br><span class="line">-a  双方都成立（and） 逻辑表达式 –a 逻辑表达式</span><br><span class="line"></span><br><span class="line">-o  单方成立（or） 逻辑表达式 –o 逻辑表达式</span><br><span class="line"></span><br><span class="line">-z  空字符串</span><br><span class="line"></span><br><span class="line">-n  非空字符串</span><br></pre></td></tr></table></figure>

<h3 id="二、逻辑表达式"><a href="#二、逻辑表达式" class="headerlink" title="二、逻辑表达式"></a>二、逻辑表达式</h3><h4 id="1-test-命令"><a href="#1-test-命令" class="headerlink" title="1. test 命令"></a>1. test 命令</h4><ul>
<li>使用方法：test EXPRESSION<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# test 1 = 1 &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# test -d /etc/ &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# test 1 -eq 1 &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# if test 1 = 1 ; then echo &#x27;ok&#x27;; fi</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h6 id="注意：所有字符-与逻辑运算符直接用“空格”分开，不能连到一起。"><a href="#注意：所有字符-与逻辑运算符直接用“空格”分开，不能连到一起。" class="headerlink" title="注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。"></a>注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。</h6></li>
</ul>
<h4 id="2-精简表达式"><a href="#2-精简表达式" class="headerlink" title="2. 精简表达式"></a>2. 精简表达式</h4><ul>
<li><strong>[]</strong> 表达式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ 1 -eq 1 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ 2 &lt; 1 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">-bash: 2: No such file or directory</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ 2 &lt; 1 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ 2 -gt 1 &amp;&amp; 3 -lt 4 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">-bash: [: missing `]&#x27;</span><br></pre></td></tr></table></figure>
<h6 id="注意：在-表达式中，常见的-gt-lt-需要加转义字符，表示字符串大小比较，以acill码-位置作为比较。-不直接支持-lt-gt-运算符，还有逻辑运算符-amp-amp-它需要用-a-and-–o-or-表示"><a href="#注意：在-表达式中，常见的-gt-lt-需要加转义字符，表示字符串大小比较，以acill码-位置作为比较。-不直接支持-lt-gt-运算符，还有逻辑运算符-amp-amp-它需要用-a-and-–o-or-表示" class="headerlink" title="注意：在[]表达式中，常见的&gt;,&lt;需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。 不直接支持&lt;&gt;运算符，还有逻辑运算符|| &amp;&amp; 它需要用-a[and] –o[or]表示"></a>注意：在<code>[]</code>表达式中，常见的<code>&gt;,&lt;</code>需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。 不直接支持<code>&lt;&gt;</code>运算符，还有逻辑运算符<code>||</code> <code>&amp;&amp;</code> 它需要用<code>-a[and]</code> <code>–o[or]</code>表示</h6></li>
<li><strong>[[]]</strong> 表达式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ 1 -eq 1 ] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$ [[ 2 &lt; 3 ]] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$ [[ 2 &lt; 3 &amp;&amp; 4 &gt; 5 ]] &amp;&amp; echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h6 id="注意：-运算符只是-运算符的扩充。能够支持-lt-gt-符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：-amp-amp"><a href="#注意：-运算符只是-运算符的扩充。能够支持-lt-gt-符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：-amp-amp" class="headerlink" title="注意：[[]] 运算符只是[]运算符的扩充。能够支持&lt;,&gt;符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| &amp;&amp;"></a>注意：<code>[[]]</code> 运算符只是<code>[]</code>运算符的扩充。能够支持<code>&lt;,&gt;</code>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：<code>||</code> <code>&amp;&amp;</code></h6></li>
</ul>
<h4 id="3-性能比较"><a href="#3-性能比较" class="headerlink" title="3. 性能比较"></a>3. 性能比较</h4><h5 id="bash的条件表达式中有三个几乎等效的符号和命令：test，-和-。通常，大家习惯用if-then这样的形式。而-的出现，根据ABS所说，是为了兼容-gt-lt-之类的运算符。以下是比较它们性能，发现-是最快的。"><a href="#bash的条件表达式中有三个几乎等效的符号和命令：test，-和-。通常，大家习惯用if-then这样的形式。而-的出现，根据ABS所说，是为了兼容-gt-lt-之类的运算符。以下是比较它们性能，发现-是最快的。" class="headerlink" title="bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if [];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容&gt;&lt;之类的运算符。以下是比较它们性能，发现[[]]是最快的。"></a>bash的条件表达式中有三个几乎等效的符号和命令：<code>test</code>，<code>[]</code>和<code>[[]]</code>。通常，大家习惯用<code>if [];then</code>这样的形式。而<code>[[]]</code>的出现，根据ABS所说，是为了兼容<code>&gt;&lt;</code>之类的运算符。以下是比较它们性能，发现<code>[[]]</code>是最快的。</h5>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ time (for m in &#123;1..100000&#125;; do test -d .;done;)</span><br><span class="line">real 0m0.658s</span><br><span class="line">user 0m0.558s</span><br><span class="line">sys 0m0.100s</span><br><span class="line"></span><br><span class="line">$ time (for m in &#123;1..100000&#125;; do [ -d . ];done;)</span><br><span class="line">real 0m0.609s</span><br><span class="line">user 0m0.524s</span><br><span class="line">sys 0m0.085s</span><br><span class="line"></span><br><span class="line">$ time (for m in &#123;1..100000&#125;; do [[ -d . ]];done;)</span><br><span class="line">real 0m0.311s</span><br><span class="line">user 0m0.275s</span><br><span class="line">sys 0m0.036s</span><br></pre></td></tr></table></figure>
<h6 id="不考虑对低版本bash和对sh的兼容的情况下，用-是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符"><a href="#不考虑对低版本bash和对sh的兼容的情况下，用-是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符" class="headerlink" title="不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符"></a>不考虑对低版本bash和对sh的兼容的情况下，用<code>[[]]</code>是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符</h6>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/04/16/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/16/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">LVM逻辑卷基本概念及LVM的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-16 09:48:20" itemprop="dateCreated datePublished" datetime="2019-04-16T09:48:20+09:00">2019-04-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、传统的磁盘管理"><a href="#一、传统的磁盘管理" class="headerlink" title="一、传统的磁盘管理"></a>一、传统的磁盘管理</h2><p>其实在Linux操作系统中，我们的磁盘管理机制和windows上的差不多，绝大多数都是使用MBR(Master Boot Recorder)都是通过先对一个硬盘进行分区，然后再将该分区进行文件系统的格式化，在Linux系统中如果要使用该分区就将其挂载上去即可，windows的话其实底层也就是自动将所有的分区挂载好，然后我们就可以对该分区进行使用了。</p>
<p>但是这种传统的磁盘管理经常会带来很多的问题，比如说当我们使用的一个分区，其空间大小已经不再够用了，这个时候我们没有办法通过拉伸分区来进行分区扩充，当然目前也有其他第三方的磁盘管理软件可以进行磁盘的分区空间划分，但是这样会给我们的文件系统造成很大的伤害，有时会导致文件系统崩溃等问题。对于传统的磁盘管理如果说我们碰到当分区大小不足的时候，我们只能通过增加新的硬盘，然后在新的硬盘上创建分区，对分区进行格式化以后，然后将之前分区的所有东西都拷贝到新的分区里面才行。<strong>但是新增加的硬盘是作为独立的文件系统存在的，原有的文件系统并没有得到任何的扩充，上层应用只能访问到一个文件系统。</strong> 这样的方式对个人的电脑来说可能还能接受，但是如果对于生产环境下的服务器来说，这是不可接受的。因为如果要把一个分区的内容都拷贝到另一个分区上去，势必要首先卸载掉之前的那个分区，然后对整个分区进行拷贝，如果服务器上运行着一个重要的服务，比如说WWW或者FTP，其要求是 7*24 小时运行正常的，那么卸载掉分区这是不可想象的，同时如果该分区保存的内容非常非常的多，那么在对分区进行转移时时间可能会耗费很久，所以，这个时候我们就会受到传统磁盘管理的限制，因为其不能够进行动态的磁盘管理。因此，为了解决这个问题，LVM技术就诞生了！！！</p>
<h2 id="二、LVM的磁盘管理"><a href="#二、LVM的磁盘管理" class="headerlink" title="二、LVM的磁盘管理"></a>二、LVM的磁盘管理</h2><p>正是因为传统的磁盘管理不能对我们的磁盘空间进行动态的管理，因此就诞生出了LVM这个技术，那么LVM到底是什么呢？它又是怎么对磁盘进行管理的呢？</p>
<p>LVM(Logical volume Manager)是逻辑卷管理的简称。它是Linux环境下对磁盘分区进行管理的一种机制。现在不仅仅是Linux系统上可以使用LVM这种磁盘管理机制，对于其它的类UNIX操作系统，以及windows操作系统都有类似与LVM这种磁盘管理软件。</p>
<p>LVM的工作原理其实很简单，它就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取，而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。比如说我增加一个物理硬盘，这个时候上层的服务是感觉不到的，因为呈现给上次服务的是以逻辑卷的方式。</p>
<p>LVM最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。我们如果新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性！！！</p>
<h2 id="三、LVM的原理"><a href="#三、LVM的原理" class="headerlink" title="三、LVM的原理"></a>三、LVM的原理</h2><p>要想理解好LVM的原理，我们必须首先要掌握4个基本的逻辑卷概念。</p>
<ul>
<li>①PE  (Physical Extend)  物理拓展</li>
<li>②PV  (Physical Volume)  物理卷</li>
<li>③VG  (Volume Group)     卷组</li>
<li>④LV  (Logical Volume)   逻辑卷</li>
</ul>
<p>我们知道在使用LVM对磁盘进行动态管理以后，我们是以逻辑卷的方式呈现给上层的服务的。所以我们所有的操作目的，其实就是去创建一个LV(Logical Volume),逻辑卷就是用来取代我们之前的分区，我们通过对逻辑卷进行格式化，然后进行挂载操作就可以使用了。那么LVM的工作原理是什么呢？所谓无图无真相，咱们下面通过图来对逻辑卷的原理进行解释！！</p>
<p><img src="/assets/lvm1.jpg" alt="lvm1"></p>
<h4 id="1-将我们的物理硬盘格式化成PV-Physical-Volume"><a href="#1-将我们的物理硬盘格式化成PV-Physical-Volume" class="headerlink" title="1.将我们的物理硬盘格式化成PV(Physical Volume)"></a>1.将我们的物理硬盘格式化成PV(Physical Volume)</h4><p>我们看到，这里有两块硬盘，一块是sda，另一块是sdb，在LVM磁盘管理里，我首先要将这两块硬盘格式化为我们的PV(Physical Volume),也就是我们的物理卷，其实格式化物理卷的过程中LVM是将底层的硬盘划分为了一个一个的PE(Physical Extend),<code>我们的LVM磁盘管理中PE的默认大小是4M大小</code>，其实PE就是我们逻辑卷管理的最基本单位。比如说我有一个400M的硬盘，那么在将其格式化成PV的时候，其实际就是将这块物理硬盘划分成了100个的PE，因为PE默认的大小就是4M。这个就是我们的第一步操作。</p>
<h4 id="2-创建一个VG-Volume-Group"><a href="#2-创建一个VG-Volume-Group" class="headerlink" title="2.创建一个VG(Volume Group)"></a>2.创建一个VG(Volume Group)</h4><p>在将硬盘格式化成PV以后，我们第二步操作就是创建一个卷组，也就是VG(Volume Group),卷组在这里我们可以将其抽象化成一个空间池，VG的作用就是用来装PE的，我们可以把一个或者多个PV加到VG当中，因为在第一步操作时就已经将该硬盘划分成了多个PE，所以将多个PV加到VG里面后，VG里面就存放了许许多多来自不同PV中的PE，我们通过上面的图片就可以看到，我们格式化了两块硬盘，每个硬盘分别格式化成了3个PE，然后将两块硬盘的PE都加到了我们的VG当中，那么我们的VG当中就包含了6个PE，这6个PE就是两个硬盘的PE之和。通常创建一个卷组的时候我们会为其取一个名字，也就是该VG的名字。</p>
<h4 id="3-基于VG创建我们最后要使用的LV-Logical-Volume"><a href="#3-基于VG创建我们最后要使用的LV-Logical-Volume" class="headerlink" title="3.基于VG创建我们最后要使用的LV(Logical Volume)"></a>3.基于VG创建我们最后要使用的LV(Logical Volume)</h4><p>【注意】PV以及VG创建好以后我们是不能够直接使用的，因为PV、VG是我们逻辑卷底层的东西，我们其实最后使用的是在VG基础上创建的LV(Logical Volume),所以第三步操作就是基于VG来创建我们最终要使用的LV。</p>
<p>当我们创建好我们的VG以后，这个时候我们创建LV其实就是从VG中拿出我们指定数量的PE，还是拿上图来说，我们看到我们此时的VG里面已经拥有了6个PE，这时候我们创建了我们的第一个逻辑卷，它的大小是4个PE的大小，也就是16M(<code>因为一个PE的默认大小是4M</code>)，而这4个PE有三个是来自于第一块硬盘，而另外一个PE则是来自第二块硬盘。当我们创建第二个逻辑卷时，它的大小就最多只有两个PE的大小了，因为其中的4个PE已经分配给了我们的第一个逻辑卷。</p>
<p><code>所以创建逻辑卷其实就是我们从VG中拿出我们指定数量的PE，VG中的PE可以来自不同的PV，我们可以创建的逻辑卷的大小取决于VG当中PE存在的数量，并且我们创建的逻辑卷其大小一定是PE的整数倍(即逻辑卷的大小一定要是4M的整数倍)。</code></p>
<h4 id="4-将我们创建好的LV进行文件系统的格式化，然后挂载使用"><a href="#4-将我们创建好的LV进行文件系统的格式化，然后挂载使用" class="headerlink" title="4.将我们创建好的LV进行文件系统的格式化，然后挂载使用"></a>4.将我们创建好的LV进行文件系统的格式化，然后挂载使用</h4><p>在创建好LV以后，这个时候我们就能够对其进行文件系统的格式化了，我们最终使用的就是我们刚创建好的LV，其就相当于传统的文件管理的分区，我们首先要对其进行文件系统的格式化操作，然后通过mount命令对其进行挂载，这个时候我们就能够像使用平常的分区一样来使用我们的逻辑卷了。</p>
<p>我们在创建好LV以后，我们会在 <code>/dev</code> 目录下看到我们的LV信息，例如 <code>/dev/vgname/lvname</code>， 我们每创建一个VG，其会在<code>/dev</code>目录下创建一个以该VG名字命名的文件夹，在该VG的基础上创建好LV以后，我们会在这个VG目录下多出一个以LV名字命名的逻辑卷。</p>
<p>下面我们来对整个LVM的工作原理进行一个总结：</p>
<ul>
<li>(1)物理磁盘被格式化为PV，空间被划分为一个个的PE</li>
<li>(2)不同的PV加入到同一个VG中，不同PV的PE全部进入到了VG的PE池内</li>
<li>(3)LV基于PE创建，大小为PE的整数倍，组成LV的PE可能来自不同的物理磁盘</li>
<li>(4)LV现在就直接可以格式化后挂载使用了</li>
<li>(5)LV的扩充缩减实际上就是增加或减少组成该LV的PE数量，其过程不会丢失原始数据</li>
</ul>
<p><img src="/assets/lvm2.jpg" alt="lvm2"></p>
<p>我们看到，我们这里如果要对LV进行扩充，直接加进来一块sdc硬盘，然后将其格式化成PE，然后将该PV加入到了VG当中，这个时候我们就可以通过增加LV中PE的数量来动态的对LV进行扩充了，只要我们的LV的大小不要超过我们VG空余空间的大小就行了！！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/04/09/MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/09/MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">1000行 MySQL 学习笔记，不怕你不会，就怕你不学！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-09 12:01:20" itemprop="dateCreated datePublished" datetime="2019-04-09T12:01:20+09:00">2019-04-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1000行-MySQL-学习笔记，不怕你不会，就怕你不学！"><a href="#1000行-MySQL-学习笔记，不怕你不会，就怕你不学！" class="headerlink" title="1000行 MySQL 学习笔记，不怕你不会，就怕你不学！"></a>1000行 MySQL 学习笔记，不怕你不会，就怕你不学！</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YX1XqKVfPS9DpMi_gTFNiA">原文</a></li>
</ul>
<h3 id="连接与断开服务器"><a href="#连接与断开服务器" class="headerlink" title="连接与断开服务器"></a>连接与断开服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure>

<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE  PATTERN ]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure>

<h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT  string ]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">        AUTO_INCREMENT = 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY =  目录 </span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY =  目录 </span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT =  string </span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE  pattern ]</span><br><span class="line">    SHOW TABLES FROM 表名</span><br><span class="line">-- 查看表机构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE  PATTERN ]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE  pattern ]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE=MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</span><br></pre></td></tr></table></figure>

<h3 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE  character_set_%    -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 = 变量值</span><br><span class="line">    SET character_set_client = gbk;</span><br><span class="line">    SET character_set_results = gbk;</span><br><span class="line">    SET character_set_connection = gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE  pattern ]/SHOW CHARSET [LIKE  pattern ]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE  pattern ]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure>

<h3 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h3><ul>
<li>数值类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数 123 ，补填后为 00123 </span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line"></span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line"></span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</span><br><span class="line"></span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line"></span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>日期时间类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br></pre></td></tr></table></figure></li>
<li><p>枚举和集合</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set( 男 ,  女 ,  无 ) );</span><br><span class="line">    insert into tab values ( 男, 女 );</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure>

<h3 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- PHP角度</span><br><span class="line">1. 功能满足</span><br><span class="line">2. 存储空间尽量小，处理效率更高</span><br><span class="line">3. 考虑兼容问题</span><br><span class="line"></span><br><span class="line">-- IP存储 ----------</span><br><span class="line">1. 只需存储，可用字符串</span><br><span class="line">2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned</span><br><span class="line">    1) PHP函数转换</span><br><span class="line">        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。</span><br><span class="line">        利用sprintf函数格式化字符串</span><br><span class="line">        sprintf(&quot;%u&quot;, ip2long( 192.168.3.134 ));</span><br><span class="line">        然后用long2ip将整型转回IP字符串</span><br><span class="line">    2) MySQL函数转换(无符号整型，UNSIGNED)</span><br><span class="line">        INET_ATON( 127.0.0.1 ) 将IP转为整型</span><br><span class="line">        INET_NTOA(2130706433) 将整型转为IP</span><br></pre></td></tr></table></figure>

<h3 id="列属性（列约束）"><a href="#列属性（列约束）" class="headerlink" title="列属性（列约束）"></a>列属性（列约束）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null,  val );</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default,  val );    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment  注释内容 ;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure>

<h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- Normal Format, NF</span><br><span class="line">     - 每个表保存一个实体信息</span><br><span class="line">     - 每个具有一个ID字段作为主键</span><br><span class="line">     - ID主键 + 原子表</span><br><span class="line"> -- 1NF, 第一范式</span><br><span class="line">     字段不能再分，就满足第一范式。</span><br><span class="line"> -- 2NF, 第二范式</span><br><span class="line">     满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">     消除符合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line"> -- 3NF, 第三范式</span><br><span class="line">     满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">     某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">     将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure>

<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is/is not 加上ture/false/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure>

<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将多个select查询的结果组合成一个结果集合。</span><br><span class="line"> SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line"> 默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line"> 建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line"> ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line"> 需要各select查询的字段数量一样。</span><br><span class="line"> 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money = (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    != all()    相当于 not in</span><br><span class="line">    = some()    相当于 in。any 是 some 的别名</span><br><span class="line">    != some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure>

<h3 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">    </span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;</span><br></pre></td></tr></table></figure>

<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据</span><br><span class="line"></span><br><span class="line">load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据</span><br><span class="line">    生成的数据默认的分隔符是制表符</span><br><span class="line">    local未指定，则数据文件必须在服务器上</span><br><span class="line">    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理</span><br><span class="line">-- 控制格式</span><br><span class="line">fields  控制字段格式</span><br><span class="line">默认：fields terminated by  	  enclosed by    escaped by   </span><br><span class="line">    terminated by  string   -- 终止</span><br><span class="line">    enclosed by  char       -- 包裹</span><br><span class="line">    escaped by  char        -- 转义</span><br><span class="line">    -- 示例：</span><br><span class="line">        SELECT a,b,a+b INTO OUTFILE  /tmp/result.text </span><br><span class="line">        FIELDS TERMINATED BY  ,  OPTIONALLY ENCLOSED BY  &quot; </span><br><span class="line">        LINES TERMINATED BY  </span><br><span class="line"> </span><br><span class="line">        FROM test_table;</span><br><span class="line">lines   控制行格式</span><br><span class="line">默认：lines terminated by  </span><br><span class="line"> </span><br><span class="line">    terminated by  string   -- 终止</span><br></pre></td></tr></table></figure>

<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select语句获得的数据可以用insert插入。</span><br><span class="line">可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。</span><br><span class="line">    或者使用set语法。</span><br><span class="line">    INSERT INTO tbl_name SET field=value,...；</span><br><span class="line">可以一次性使用多个值，采用(), (), ();的形式。</span><br><span class="line">    INSERT INTO tbl_name VALUES (), (), ();</span><br><span class="line">可以在列值指定时，使用表达式。</span><br><span class="line">    INSERT INTO tbl_name VALUES (field_value, 10+10, now());</span><br><span class="line">可以使用一个特殊值 DEFAULT，表示该列使用默认值。</span><br><span class="line">    INSERT INTO tbl_name VALUES (field_value, DEFAULT);</span><br><span class="line">可以通过一个查询的结果，作为需要插入的值。</span><br><span class="line">    INSERT INTO tbl_name SELECT ...;</span><br><span class="line">可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。</span><br><span class="line">    INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;</span><br></pre></td></tr></table></figure>

<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]</span><br><span class="line">按照条件删除。where</span><br><span class="line">指定删除的最多记录数。limit</span><br><span class="line">可以通过排序条件删除。order by + limit</span><br><span class="line">支持多表删除，使用类似连接语法。</span><br><span class="line">delete from 需要删除数据多表1，表2 using 表连接操作 条件。</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure>

<h3 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">    mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">    mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">    mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">    mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">    source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">    mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure>

<h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据晚自习方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure>

<h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line"></span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line"></span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line"></span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure>

<h3 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">--// 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--// 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var = value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。</span><br><span class="line">select @var:=20;</span><br><span class="line">select @v1:=id, @v2=name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:=30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var=10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--// 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--// 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) = 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) = 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) = 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3=1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date( yyyy-mm-dd hh:ii:ss );    -- 获取日期部分</span><br><span class="line">time( yyyy-mm-dd hh:ii:ss );    -- 获取时间部分</span><br><span class="line">date_format( yyyy-mm-dd hh:ii:ss ,  %d %y %a %d %m %b %j ); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line"></span><br><span class="line">--// 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE  partten </span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line"></span><br><span class="line">--// 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 存储过程 */ ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如  user_name @ 192.168.1.1 </span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD = PASSWORD( 密码 )  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 = PASSWORD( 密码 ) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限/添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD]  password ]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON `pms`.* TO  pms @ %  IDENTIFIED BY  pms0817 ;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure>

<h3 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 /* 注释内容 */</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义  </span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;G&quot;, &quot;g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：c</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/02/25/Linux-Performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/25/Linux-Performance/" class="post-title-link" itemprop="url">Linux Performance</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-25 12:33:20" itemprop="dateCreated datePublished" datetime="2019-02-25T12:33:20+09:00">2019-02-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Linux-Performance"><a href="#Linux-Performance" class="headerlink" title="Linux Performance"></a>Linux Performance</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/linuxperf.html">原文</a></li>
</ul>
<h4 id="linux-observability-tools"><a href="#linux-observability-tools" class="headerlink" title="linux_observability_tools"></a>linux_observability_tools</h4><p><img src="/assets/linux_observability_tools.jpg" alt="linux_observability_tools"></p>
<h4 id="linux-benchmarking-tools"><a href="#linux-benchmarking-tools" class="headerlink" title="linux_benchmarking_tools"></a>linux_benchmarking_tools</h4><p><img src="/assets/linux_benchmarking_tools.jpg" alt="linux_benchmarking_tools"></p>
<h4 id="linux-tuning-tools"><a href="#linux-tuning-tools" class="headerlink" title="linux_tuning_tools"></a>linux_tuning_tools</h4><p><img src="/assets/linux_tuning_tools.jpg" alt="linux_tuning_tools"></p>
<h4 id="linux-static-tools"><a href="#linux-static-tools" class="headerlink" title="linux_static_tools"></a>linux_static_tools</h4><p><img src="/assets/linux_static_tools.jpg" alt="linux_static_tools"></p>
<h4 id="linux-observability-sar"><a href="#linux-observability-sar" class="headerlink" title="linux_observability_sar"></a>linux_observability_sar</h4><p><img src="/assets/linux_observability_sar.jpg" alt="linux_observability_sar"></p>
<h4 id="perf-tools-2016"><a href="#perf-tools-2016" class="headerlink" title="perf-tools_2016"></a>perf-tools_2016</h4><p><img src="/assets/perf-tools_2016.jpg" alt="perf-tools_2016"></p>
<h4 id="bcc-tracing-tools"><a href="#bcc-tracing-tools" class="headerlink" title="bcc_tracing_tools"></a>bcc_tracing_tools</h4><p><img src="/assets/bcc_tracing_tools.jpg" alt="bcc_tracing_tools"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/02/07/python-decorator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/07/python-decorator/" class="post-title-link" itemprop="url">跨过这道装饰器的坎，或许你就升级了</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-07 12:51:20" itemprop="dateCreated datePublished" datetime="2019-02-07T12:51:20+09:00">2019-02-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>装饰器是一个非常重要的 Python 概念，可能算是进阶的一大门槛。本文比较全面地对装饰器进行了介绍，并且配备了详细的代码示例，推荐阅读。</p>
</blockquote>
<p>作者：Toby<br>原文：<a target="_blank" rel="noopener" href="https://betacat.online/posts/python-decorator/index.html">https://betacat.online/posts/python-decorator/index.html</a></p>
<p>Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。</p>
<h2 id="为什么需要装饰器"><a href="#为什么需要装饰器" class="headerlink" title="为什么需要装饰器"></a>为什么需要装饰器</h2><p>我们假设你的程序实现了 <code>say_hello ()</code> 和 <code>say_goodbye ()</code> 两个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span>  <span class="comment"># bug here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   say_hello()</span><br><span class="line">   say_goodbye()</span><br></pre></td></tr></table></figure>

<p>但是在实际调用中，我们发现程序出错了，上面的代码打印了两个 hello 。经过调试你发现是 <code>say_goodbye ()</code> 出错了。老板要求调用每个方法前都要记录进入函数的时间和名称，比如这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] <span class="number">2016</span> - <span class="number">10</span> - <span class="number">27</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> - Enter say_hello()</span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">[DEBUG] <span class="number">2016</span> - <span class="number">10</span> - <span class="number">27</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span> - Enter say_goodbye()</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure>
<p>好，小 A 是个毕业生，他是这样实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter say_hello()&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter say_goodbye()&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   say_hello()</span><br><span class="line">   say_goodbye()</span><br></pre></td></tr></table></figure>
<p>很 low 吧？ 嗯是的。小 B 工作有一段时间了，他告诉小 A 应该这样写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>():</span></span><br><span class="line">   <span class="keyword">import</span> inspect</span><br><span class="line">   caller_name = inspect.stack()[<span class="number">1</span>][<span class="number">3</span>]    </span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(caller_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">   debug()    </span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span>():</span></span><br><span class="line">   debug()    </span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;goodbye!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   say_hello()</span><br><span class="line">   say_goodbye()</span><br></pre></td></tr></table></figure>

<p>是不是好一点？那当然，但是每个业务函数里都要调用一下 debug () 函数，是不是很难受？万一老板说 say 相关的函数不用 debug ， do 相关的才需要呢？</p>
<p>那么装饰器这时候应该登场了。</p>
<blockquote>
<p>装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
</blockquote>
<p>概括的讲，装饰器的作用就是<code>为已经存在的函数或对象添加额外的功能。</code></p>
<p>怎么写一个装饰器</p>
<p>在早些时候  (Python Version &lt; 2.4，2004年以前)，为一个函数添加额外功能的写法是这样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func()    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line">say_hello = debug(say_hello)  <span class="comment"># 添加功能并保持原函数名不变</span></span><br></pre></td></tr></table></figure>
<p>上面的 debug 函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，下面代码等同于早期的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func()    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数 <code>wrapper</code> 接受和原函数一样的参数，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">something</span>):</span>  <span class="comment"># 指定一毛一样的参数</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func(something)    </span><br><span class="line">   <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装过函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br></pre></td></tr></table></figure>

<p>这样你就解决了一个问题，但又多了 N 个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好 Python 提供了可变参数 <code>* args</code> 和关键字参数 <code>** kwargs</code> ，有了这两个参数，装饰器就可以用于任意目标函数了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>  <span class="comment"># 指定宇宙无敌参数</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__)        </span><br><span class="line">       <span class="built_in">print</span> <span class="string">&#x27;Prepare and say...&#x27;</span>,        </span><br><span class="line">       <span class="keyword">return</span> func(*args, **kwargs)    </span><br><span class="line">   <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br></pre></td></tr></table></figure>
<p>至此，你已完全掌握初级的装饰器写法。</p>
<h2 id="高级一点的装饰器"><a href="#高级一点的装饰器" class="headerlink" title="高级一点的装饰器"></a>高级一点的装饰器</h2><p>带参数的装饰器和类装饰器属于进阶的内容。在理解这些装饰器之前，最好对函数的闭包和装饰器的接口约定有一定了解。(参见<a target="_blank" rel="noopener" href="http://betacat.online/posts/python-">http://betacat.online/posts/python-</a> closure/)</p>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出 log 信息，而且还需指定 log 的级别，那么装饰器就会是这样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">level</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">               level=level,</span><br><span class="line">               func=func.__name__)            </span><br><span class="line">           <span class="keyword">return</span> func(*args, **kwargs)        </span><br><span class="line">       <span class="keyword">return</span> inner_wrapper    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;DEBUG&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;do &#123;&#125;...&quot;</span>.<span class="built_in">format</span>(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   say(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">   do(<span class="string">&quot;my work&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如 <code>@ logging ( level =&#39; DEBUG &#39;)</code> ，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p>
<h2 id="基于类实现的装饰器"><a href="#基于类实现的装饰器" class="headerlink" title="基于类实现的装饰器"></a>基于类实现的装饰器</h2><p>装饰器函数其实是这样一个接口约束，它必须接受一个 callable 对象作为参数，然后返回一个 callable 对象。在 Python 中一般 callable 对象都是函数，但也有例外。只要某个对象重载了 <code>__call__ ()</code> 方法，那么这个对象就是 callable 的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>():</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&#x27;call me!&#x27;</span>t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure>

<p>像 <code>__call__</code> 这样前后都带下划线的方法在 Python 中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p>
<p>回到装饰器上的概念上来，装饰器要求接受一个 callable 对象，并返回一个 callable 对象（不太严谨，详见后文）。那么用类来实现也是也可以的。我们可以让类的构造函数 <code>__init__ ()</code> 接受一个函数，然后重载 <code>__call__ ()</code> 并返回一个函数，也可以达到装饰器函数的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">       self.func = func    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">           func=self.func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br></pre></td></tr></table></figure>

<h2 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h2><p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载 <code>__call__</code> 方法是就需要接受一个函数并返回一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span></span><br><span class="line">       self.level = level    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span>  <span class="comment"># 接受函数</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">               level=self.level,</span><br><span class="line">               func=func.__name__)</span><br><span class="line">           func(*args, **kwargs)        </span><br><span class="line">           <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br></pre></td></tr></table></figure>

<h2 id="内置的装饰器"><a href="#内置的装饰器" class="headerlink" title="内置的装饰器"></a>内置的装饰器</h2><p>内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象，所以更难理解一些。</p>
<h3 id="property"><a href="#property" class="headerlink" title="@ property"></a>@ property</h3><p>在了解这个装饰器前，你需要知道在不使用装饰器怎么写一个属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getx</span>(<span class="params">self</span>):</span></span><br><span class="line">   <span class="keyword">return</span> self._x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setx</span>(<span class="params">self, value</span>):</span></span><br><span class="line">   self._x = value</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delx</span>(<span class="params">self</span>):</span></span><br><span class="line">   <span class="keyword">del</span> self._x<span class="comment"># create a property</span></span><br><span class="line">x = <span class="built_in">property</span>(getx, setx, delx, <span class="string">&quot;I am doc for x property&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上就是一个Python属性的标准写法，其实和Java挺像的，能达到一样的效果但看起来更简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span> ...</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">x = <span class="built_in">property</span>(x)</span><br></pre></td></tr></table></figure>

<p>属性有三个装饰器： <code>setter</code> , <code>getter</code> , <code>deleter</code> ，都是在 <code>property ()</code> 的基础上做了一些封装，因为 <code>setter</code> 和 <code>deleter</code> 是 <code>property ()</code> 的第二和第三个参数，<code>getter</code> 装饰器和不带 <code>getter</code> 的属性装饰器效果是一样的，估计只是为了凑数，本身没有任何存在的意义。经过 <code>@ property</code> 装饰过的函数返回的不再是一个函数，而是一个 <code>property</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">property</span>()</span><br><span class="line">&lt;<span class="built_in">property</span> <span class="built_in">object</span> at <span class="number">0x10ff07940</span> &gt;</span><br></pre></td></tr></table></figure>

<h3 id="classmethod"><a href="#classmethod" class="headerlink" title="@ classmethod"></a>@ classmethod</h3><p>有了 <code>@ property</code> 装饰器的了解，这两个装饰器的原理是差不多的。 <code>@ staticmethod</code> 返回的是一个 <code>staticmethod</code> 类对象，而 <code>@ classmethod</code> 返回的是一个 <code>classmethod</code> 类对象。他们都是调用的是各自的 <code>__init__ ()</code> 构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   classmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span>  <span class="comment"># for @classmethod decorator</span></span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   staticmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span>  <span class="comment"># for @staticmethod decorator</span></span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="comment"># 等同于 bar = staticmethod(bar)</span></span><br></pre></td></tr></table></figure>

<p>至此，我们上文提到的装饰器接口定义可以更加明确一些，装饰器必须接受一个 callable 对象，其实它并不关心你返回什么，可以是另外一个 callable 对象（大部分情况），也可以是其他类对象，比如 property 。</p>
<h2 id="装饰器里的那些坑"><a href="#装饰器里的那些坑" class="headerlink" title="装饰器里的那些坑"></a>装饰器里的那些坑</h2><p>装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。</p>
<h3 id="位置错误的代码"><a href="#位置错误的代码" class="headerlink" title="位置错误的代码"></a>位置错误的代码</h3><p>让我们直接看示例代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_tags</span>(<span class="params">tag_name</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;begin outer function.&#x27;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper_</span>(<span class="params">func</span>):</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;begin of inner wrapper function.&quot;</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">           content = func(*args, **kwargs)            </span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;&lt;&#123;tag&#125;&gt;&#123;content&#125;&lt;/&#123;tag&#125;&gt;&quot;</span>.<span class="built_in">format</span>(tag=tag_name, content=content)               <span class="built_in">print</span> <span class="string">&#x27;end of inner wrapper function.&#x27;</span></span><br><span class="line">       <span class="keyword">return</span> wrapper    </span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;end of outer function&#x27;</span></span><br><span class="line">   <span class="keyword">return</span> wrapper_@html_tags(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name=<span class="string">&#x27;Toby&#x27;</span></span>):</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">hello()</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>在装饰器中我在各个可能的位置都加上了 print 语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了。以下是输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin outer function.</span><br><span class="line">end of outer function</span><br><span class="line">begin of inner wrapper function.</span><br><span class="line">end of inner wrapper function.</span><br><span class="line">&lt;b &gt; Hello Toby!&lt; /b &gt;</span><br><span class="line">&lt;b &gt; Hello Toby!&lt; /b &gt;</span><br></pre></td></tr></table></figure>

<h3 id="错误的函数签名和文档"><a href="#错误的函数签名和文档" class="headerlink" title="错误的函数签名和文档"></a>错误的函数签名和文档</h3><p>装饰器装饰过的函数看上去名字没变，其实已经变了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;print log before a function.&quot;&quot;&quot;</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG] &#123;&#125;: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(datetime.now(), func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func(*args, **kwargs)    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;say something&quot;&quot;&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br><span class="line"><span class="built_in">print</span> say.__name__  <span class="comment"># wrapper</span></span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？@等同于这样的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say = logging(say)</span><br></pre></td></tr></table></figure>

<p><code>logging</code> 其实返回的函数名字刚好是 <code>wrapper</code> ，那么上面的这个语句刚好就是把这个结果赋值给 <code>say</code> ， <code>say</code> 的 <code>__name__</code> 自然也就是 <code>wrapper</code> 了，不仅仅是 <code>name</code> ，其他属性也都是来自 <code>wrapper</code> ，比如 <code>doc</code> ， <code>source</code> 等等。</p>
<p>使用标准库里的 functools.wraps ，可以基本解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wrapsdef logging(func):</span><br><span class="line"><span class="meta">   @wraps(<span class="params">func</span>)</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;print log before a function.&quot;&quot;&quot;</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[DEBUG] &#123;&#125;: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(datetime.now(), func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func(*args, **kwargs)    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;say something&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something)</span><br><span class="line">   <span class="built_in">print</span> say.__name__  <span class="comment"># say</span></span><br><span class="line">   <span class="built_in">print</span> say.__doc__  <span class="comment"># say something</span></span><br></pre></td></tr></table></figure>

<p>看上去不错！主要问题解决了，但其实还不太完美。因为函数的签名和源码还是拿不到的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="built_in">print</span> inspect.getargspec(say)  <span class="comment"># failed</span></span><br><span class="line"><span class="built_in">print</span> inspect.getsource(say)  <span class="comment"># failed</span></span><br></pre></td></tr></table></figure>

<p>如果要彻底解决这个问题可以借用第三方包，比如 <code>wrapt</code> 。后文有介绍。</p>
<h2 id="不能装饰-staticmethod-或者-classmethod"><a href="#不能装饰-staticmethod-或者-classmethod" class="headerlink" title="不能装饰@staticmethod 或者 @classmethod"></a>不能装饰@staticmethod 或者 @classmethod</h2><p>当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model</span>):</span></span><br><span class="line">       self.model = model    </span><br><span class="line">   </span><br><span class="line"><span class="meta">   @logging  </span><span class="comment"># 装饰实例方法，OK</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;&#123;&#125; is running!&quot;</span>.<span class="built_in">format</span>(self.model)    </span><br><span class="line">   </span><br><span class="line"><span class="meta">   @logging  </span><span class="comment"># 装饰静态方法，Failed</span></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">check_model_for</span>(<span class="params">obj</span>):</span></span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, Car):            </span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;The model of your car is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(obj.model)        </span><br><span class="line">       <span class="keyword">else</span>:            </span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;&#123;&#125; is not a car!&quot;</span>.<span class="built_in">format</span>(obj)     </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"> File &quot;example_4.py&quot;, line 10, in logging</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   @wraps(func)</span></span><br><span class="line"><span class="string"> File &quot;C:\Python27\lib\functools.py&quot;, line 33, in update_wrapper</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   setattr(wrapper, attr, getattr(wrapped, attr))</span></span><br><span class="line"><span class="string">AttributeError: &#x27;staticmethod&#x27; object has no attribute &#x27;__module__&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>前面已经解释了 <code>@ staticmethod</code> 这个装饰器，其实它返回的并不是一个 <code>callable</code> 对象，而是一个 <code>staticmethod</code> 对象，那么它是不符合装饰器要求的（比如传入一个 callable 对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在 <code>@ staticmethod</code> 之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个 <code>@ staticmethod</code> 是不会出问题的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model</span>):</span></span><br><span class="line">       self.model = model    </span><br><span class="line">   </span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line"><span class="meta">   @logging  </span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">check_model_for</span>(<span class="params">obj</span>):</span></span><br><span class="line">       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="如何优化你的装饰器"><a href="#如何优化你的装饰器" class="headerlink" title="如何优化你的装饰器"></a>如何优化你的装饰器</h2><p>嵌套的装饰函数不太直观，我们可以使用第三方包类改进这样的情况，让装饰器函数可读性更好。</p>
<h3 id="decorator-py"><a href="#decorator-py" class="headerlink" title="decorator.py"></a>decorator.py</h3><p><code>decorator.py</code>是一个非常简单的装饰器加强包。你可以很直观的先定义包装函数 <code>wrapper ()</code> ，再使用 <code>decorate ( func , wrapper )</code> 方法就可以完成一个装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func, *args, **kwargs</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;print log before a function.&quot;&quot;&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG] &#123;&#125;: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(datetime.now(), func.__name__)    </span><br><span class="line">   <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="keyword">return</span> decorate(func, wrapper)  <span class="comment"># 用wrapper装饰func</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用它自带的 <code>@ decorator</code> 装饰器来完成你的装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorator</span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">func, *args, **kwargs</span>):</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG] &#123;&#125;: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(datetime.now(), func.__name__)    </span><br><span class="line">   <span class="keyword">return</span> func(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p><code>decorator.py</code> 实现的装饰器能完整保留原函数的 <code>name</code> ， <code>doc</code> 和 <code>args</code> ，唯一有问题的就是 <code>inspect.getsource ( func )</code> 返回的还是装饰器的源代码，你需要改成 <code>inspect.getsource ( func.__wrapped__ )</code> 。</p>
<h3 id="wrapt"><a href="#wrapt" class="headerlink" title="wrapt"></a>wrapt</h3><p><code>wrapt</code>是一个功能非常完善的包，用于实现各种你想到或者你没想到的装饰器。使用 wrapt 实现的装饰器你不需要担心之前 inspect 中遇到的所有问题，因为它都帮你处理了，甚至 <code>inspect.getsource ( func )</code> 也准确无误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wrapt<span class="comment"># without argument in decorator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapt.decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">wrapped, instance, args, kwargs</span>):</span>  <span class="comment"># instance is must</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(wrapped.__name__)    </span><br><span class="line">   <span class="keyword">return</span> wrapped(*args, **kwargs)</span><br><span class="line">   </span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">something</span>):</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>wrapt</code> 你只需要定义一个装饰器函数，但是函数签名是固定的，必须是 <code>( wrapped , instance, args, kwargs )</code> ，注意第二个参数 <code>instance</code> 是必须的，就算你不用它。当装饰器装饰在不同位置时它将得到不同的值，比如装饰在类实例方法时你可以拿到这个类实例。根据 <code>instance</code> 的值你能够更加灵活的调整你的装饰器。另外， <code>args</code> 和 <code>kwargs</code> 也是固定的，注意前面没有星号。在装饰器内部调用原函数时才带星号。</p>
<p>如果你需要使用 wrapt 写一个带参数的装饰器，可以这样写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">level</span>):</span></span><br><span class="line"><span class="meta">   @wrapt.decorator</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">wrapped, instance, args, kwargs</span>):</span></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;[&#123;&#125;]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(level, wrapped.__name__)        </span><br><span class="line">       <span class="keyword">return</span> wrapped(*args, **kwargs)    </span><br><span class="line">   <span class="keyword">return</span> wrapper@logging(level=<span class="string">&quot;INFO&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span>(<span class="params">work</span>):</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>关于 wrapt 的使用，建议查阅官方文档，在此不在赘述。<br><a target="_blank" rel="noopener" href="http://wrapt.readthedocs.io/en/latest/quick-start.html">http://wrapt.readthedocs.io/en/latest/quick-start.html</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python 的装饰器和 Java 的注解（ Annotation ）并不是同一回事，和 C# 中的特性（ Attribute ）也不一样，完全是两个概念。</p>
<p>装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为 <code>wrapper ()</code> ，意义在于包装。函数只有在被调用时才会发挥其作用。比如 <code>@ logging</code> 装饰器可以在函数执行时额外输出日志， <code>@ cache</code> 装饰过的函数可以缓存计算结果等等。</p>
<p>而注解和特性则是对目标函数或对象添加一些属性，相当于将其分类。这些属性可以通过反射拿到，在程序运行时对不同的特性函数或对象加以干预。比如带有 <code>Setup</code> 的函数就当成准备步骤执行，或者找到所有带有 <code>TestMethod</code> 的函数依次执行等等。</p>
<p>至此我所了解的装饰器已经讲完，但是还有一些内容没有提到，比如装饰类的装饰器。有机会再补充。谢谢观看。</p>
<blockquote>
<p>本文源码 &lt;<a target="_blank" rel="noopener" href="https://github.com/tobyqin/python_decorator">https://github.com/tobyqin/python_decorator</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/02/06/python-dunder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/06/python-dunder/" class="post-title-link" itemprop="url">Python中下划线的5种含义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-06 14:21:20" itemprop="dateCreated datePublished" datetime="2019-02-06T14:21:20+09:00">2019-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Python中下划线的5种含义"><a href="#Python中下划线的5种含义" class="headerlink" title="Python中下划线的5种含义"></a>Python中下划线的5种含义</h1><p>本文介绍了Python中单下划线和双下划线（”dunder”）的各种含义和命名约定，名称修饰（name mangling）的工作原理，以及它如何影响你自己的Python类。</p>
<p>单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。</p>
<p>如果你想知道“Python变量和方法名称中单下划线和双下划线的含义是什么？”，我会尽我所能在这里为你解答。</p>
<p>在本文中，我将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为：</p>
<ul>
<li>单前导下划线：_var</li>
<li>单末尾下划线：var_</li>
<li>双前导下划线：__var</li>
<li>双前导和末尾下划线：__var__</li>
<li>单下划线：_</li>
</ul>
<p>在文章结尾处，你可以找到一个简短的“速查表”，总结了五种不同的下划线命名约定及其含义，以及一个简短的视频教程，可让你亲身体验它们的行为。</p>
<h3 id="1-单前导下划线-var"><a href="#1-单前导下划线-var" class="headerlink" title="1. 单前导下划线 _var"></a>1. 单前导下划线 _var</h3><p>当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python社区一致认为它应该是什么意思，但程序的行为不受影响。</p>
<p>下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。</p>
<p>这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说：</p>
<blockquote>
<p>“嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“<br>看看下面的例子：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.foo = <span class="number">11</span></span><br><span class="line">       self._bar = <span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>如果你实例化此类，并尝试访问在__init__构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.foo</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._bar</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。<br>这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。</p>
<blockquote>
<p>但是，前导下划线的确会影响从模块中导入名称的方式。 </p>
</blockquote>
<p>假设你在一个名为my_module的模块中有以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is my_module.py:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">external_func</span>():</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_internal_func</span>():</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的__all__列表）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: <span class="string">&quot;name &#x27;_internal_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure>

<p>顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。<br>与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> my_module</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module.external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module._internal_func()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：</p>
<blockquote>
<p>单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。</p>
</blockquote>
<h3 id="2-单末尾下划线-var"><a href="#2-单末尾下划线-var" class="headerlink" title="2. 单末尾下划线 var_"></a>2. 单末尾下划线 var_</h3><p>有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_object</span>(<span class="params">name, <span class="keyword">class</span></span>):</span></span><br><span class="line">SyntaxError: <span class="string">&quot;invalid syntax&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_object</span>(<span class="params">name, class_</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。</p>
<h3 id="3-双前导下划线-var"><a href="#3-双前导下划线-var" class="headerlink" title="3. 双前导下划线 __var"></a>3. 双前导下划线 __var</h3><p>到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。</p>
<p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p>
<p>这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。<br>我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.foo = <span class="number">11</span></span><br><span class="line">       self._bar = <span class="number">23</span></span><br><span class="line">       self.__baz = <span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>让我们用内置的dir()函数来看看这个对象的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(t)</span><br><span class="line">[<span class="string">&#x27;_Test__baz&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;_bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称foo，_bar和__baz</p>
<ul>
<li>我保证你会注意到一些有趣的变化。<ul>
<li>self.foo变量在属性列表中显示为未修改为foo。</li>
<li>self._bar的行为方式相同 - 它以_bar的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。</li>
<li>然而，对于self.__baz而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。</li>
</ul>
</li>
</ul>
<p>__baz出什么情况了？</p>
<p>如果你仔细观察，你会看到此对象上有一个名为_Test__baz的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。</p>
<p>让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span>(<span class="params">Test</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">super</span>().__init__()</span><br><span class="line">       self.foo = <span class="string">&#x27;overridden&#x27;</span></span><br><span class="line">       self._bar = <span class="string">&#x27;overridden&#x27;</span></span><br><span class="line">       self.__baz = <span class="string">&#x27;overridden&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在，你认为foo，_bar和__baz的值会出现在这个ExtendedTest类的实例上吗？ 我们来看一看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = ExtendedTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2.foo</span><br><span class="line"><span class="string">&#x27;overridden&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2._bar</span><br><span class="line"><span class="string">&#x27;overridden&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2.__baz</span><br><span class="line">AttributeError: <span class="string">&quot;&#x27;ExtendedTest&#x27; object has no attribute &#x27;__baz&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>等一下，当我们尝试查看t2 .__ baz的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(t2)</span><br><span class="line">[<span class="string">&#x27;_ExtendedTest__baz&#x27;</span>, <span class="string">&#x27;_Test__baz&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;_bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;get_vars&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>正如你可以看到__baz变成_ExtendedTest__baz以防止意外修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2._ExtendedTest__baz</span><br><span class="line"><span class="string">&#x27;overridden&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但原来的_Test__baz还在：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2._Test__baz</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManglingTest</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.__mangled = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_mangled</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> self.__mangled</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ManglingTest().get_mangled()</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ManglingTest().__mangled</span><br><span class="line">AttributeError: <span class="string">&quot;&#x27;ManglingTest&#x27; object has no attribute &#x27;__mangled&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MangledMethod</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__method</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">call_it</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> self.__method()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MangledMethod().__method()</span><br><span class="line">AttributeError: <span class="string">&quot;&#x27;MangledMethod&#x27; object has no attribute &#x27;__method&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MangledMethod().call_it()</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>这是另一个也许令人惊讶的运用名称修饰的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_MangledGlobal__mangled = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MangledGlobal</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> __mangled</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MangledGlobal().test()</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我声明了一个名为_MangledGlobal__mangled的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以__mangled来引用_MangledGlobal__mangled全局变量。</p>
<p>Python解释器自动将名称__mangled扩展为_MangledGlobal__mangled，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。</p>
<p>有很多要吸收的内容吧。</p>
<p>老实说，这些例子和解释不是从我脑子里蹦出来的。我作了一些研究和加工才弄出来。我一直使用Python，有很多年了，但是像这样的规则和特殊情况并不总是浮现在脑海里。</p>
<p>有时候程序员最重要的技能是“模式识别”，而且知道在哪里查阅信息。如果您在这一点上感到有点不知所措，请不要担心。慢慢来，试试这篇文章中的一些例子。</p>
<p>让这些概念完全沉浸下来，以便你能够理解名称修饰的总体思路，以及我向您展示的一些其他的行为。如果有一天你和它们不期而遇，你会知道在文档中按什么来查。</p>
<h3 id="4-双前导和双末尾下划线-var"><a href="#4-双前导和双末尾下划线-var" class="headerlink" title="4. 双前导和双末尾下划线 var"></a>4. 双前导和双末尾下划线 <em>var</em></h3><p>也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixPostfixTest</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.__bam__ = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PrefixPostfixTest().__bam__</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，<strong>init__对象构造函数，或__call</strong> — 它使得一个对象可以被调用。<br>这些dunder方法通常被称为神奇方法 - 但Python社区中的许多人（包括我自己）都不喜欢这种方法。<br>最好避免在自己的程序中使用以双下划线（“dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</p>
<h3 id="5-单下划线"><a href="#5-单下划线" class="headerlink" title="5.单下划线 _"></a>5.单下划线 _</h3><p>按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。<br>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。<br>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mileage</span><br><span class="line"><span class="number">3812.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。<br>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>Python下划线命名模式 - 小结<br>以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义：</p>
<p><img src="/assets/python_dunder.jpg" alt="速查表"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2019/02/06/linux-lvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/06/linux-lvm/" class="post-title-link" itemprop="url">linux-lvm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-06 10:27:20" itemprop="dateCreated datePublished" datetime="2019-02-06T10:27:20+09:00">2019-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux环境下-LVM-逻辑卷的建立、扩容和减容操作"><a href="#Linux环境下-LVM-逻辑卷的建立、扩容和减容操作" class="headerlink" title="Linux环境下 LVM 逻辑卷的建立、扩容和减容操作"></a>Linux环境下 LVM 逻辑卷的建立、扩容和减容操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="LVM是逻辑盘卷管理（Logical-Volume-Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，"><a href="#LVM是逻辑盘卷管理（Logical-Volume-Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，" class="headerlink" title="LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，"></a>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，</h3><p>LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分LVM区管理的灵活性。<br>前面谈到，LVM是在磁盘分区和文件系统之间添加的一个逻辑层，<br>来为文件系统屏蔽下层磁盘分区布局，提供一个抽象的盘卷，在盘卷上建立文件系统。<br>物理卷（physical volume）物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样<br>功能的设备（如RAID），是LVM的基本存储逻辑块，但和基本的物理存储介质<br>（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。 </p>
<h3 id="LVM是在磁盘分区和文件系统之间添加的一个逻辑层，"><a href="#LVM是在磁盘分区和文件系统之间添加的一个逻辑层，" class="headerlink" title="LVM是在磁盘分区和文件系统之间添加的一个逻辑层，"></a>LVM是在磁盘分区和文件系统之间添加的一个逻辑层，</h3><p>来为文件系统屏蔽下层磁盘分区布局，提供一个抽象的盘卷，在盘卷上建立文件系统。首先我们讨论以下几个LVM术语：</p>
<ul>
<li><p>物理存储介质（Thephysicalmedia）</p>
<ul>
<li>这里指系统的存储设备：硬盘，是存储系统最低层的存储单元。</li>
</ul>
</li>
<li><p>物理卷（physicalvolume）</p>
<ul>
<li>物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备（如RAID），是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。</li>
</ul>
</li>
<li><p>卷组（VolumeGroup）</p>
<ul>
<li>LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</li>
</ul>
</li>
<li><p>逻辑卷（logicalvolume）</p>
<ul>
<li>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统（比如/home或者/usr等）。</li>
</ul>
</li>
<li><p>PE（physicalextent）</p>
<ul>
<li>每一个物理卷被划分为称为PE(PhysicalExtents）的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。</li>
</ul>
</li>
<li><p>LE（logicalextent）</p>
<ul>
<li>逻辑卷也被划分为被称为LE(LogicalExtents）的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。</li>
</ul>
</li>
</ul>
<h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><h5 id="———建立逻辑卷———"><a href="#———建立逻辑卷———" class="headerlink" title="———建立逻辑卷———"></a>———建立逻辑卷———</h5><ol>
<li>新建2个分区,sda5  5G,sd6 10G,完成之后如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# fdisk -l</span><br><span class="line">Disk /dev/sda: 42.9 GB, 42949672960 bytes</span><br><span class="line">255 heads, 63 sectors/track, 5221 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x000ed173</span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *           1          39      307200   83  Linux</span><br><span class="line">Partition 1 does not end on cylinder boundary.</span><br><span class="line">/dev/sda2              39        2167    17091584   83  Linux</span><br><span class="line">/dev/sda3            2167        2611     3571712   82  Linux swap / Solaris</span><br><span class="line">/dev/sda4            2611        5221    20966162+   5  Extended</span><br><span class="line">/dev/sda5            2611        3264     5246528+  83  Linux</span><br><span class="line">/dev/sda6            3265        4570    10490413+  83  Linux</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把sda6初始化物理卷</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# pvcreate /dev/sda6</span><br><span class="line">  Device vg6 not found (or ignored by filtering).</span><br><span class="line">  Writing physical volume data to disk &quot;/dev/sda6&quot;</span><br><span class="line">  Physical volume &quot;/dev/sda6&quot; successfully created</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建卷组vg6,PE为16M</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# vgcreate -s 16M vg6 /dev/sda6</span><br><span class="line">  Volume group &quot;vg6&quot; successfully created</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               vg6</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               10.00 GiB</span><br><span class="line">  PE Size               16.00 MiB</span><br><span class="line">  Total PE              640</span><br><span class="line">  Alloc PE / Size       0 / 0</span><br><span class="line">  Free  PE / Size       640 / 10.00 GiB</span><br><span class="line">  VG UUID               35tmMm-Hyec-i4f1-xkd7-pMRS-RgRl-sqFa7l</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建逻辑卷ftpdata,大小为6G</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# lvcreate -L 6G -n ftpdata vg6</span><br><span class="line">  Logical volume &quot;ftpdata&quot; created</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Name                /dev/vg6/ftpdata</span><br><span class="line">  VG Name                vg6</span><br><span class="line">  LV UUID                LSOtbB-k3mz-DVbb-ATcE-IhBk-V9B7-uaSStM</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                6.00 GiB</span><br><span class="line">  Current LE             384</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>格式化ext4,并挂载,并cp一些数据进去</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# mke2fs -T ext4 /dev/vg6/ftpdata</span><br><span class="line">[root@yangcan /]# mount /dev/vg6/ftpdata /ftpdata/</span><br><span class="line">[root@yangcan /]# cd /ftpdata/</span><br><span class="line">[root@yangcan ftpdata]# cp /etc/*.conf ./</span><br><span class="line">[root@yangcan ftpdata]# cp /usr/share/dict/linux.words ./</span><br></pre></td></tr></table></figure>


<h5 id="——–扩容——–"><a href="#——–扩容——–" class="headerlink" title="——–扩容——–"></a>——–扩容——–</h5><ol>
<li>新增一个磁盘到卷组vg6,就用到之前剩下的sda5了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan ftpdata]# vgextend vg6 /dev/sda5</span><br><span class="line">  Volume group &quot;vg6&quot; successfully extended</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               vg6</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               15.00 GiB</span><br><span class="line">  PE Size               16.00 MiB</span><br><span class="line">  Total PE              960</span><br><span class="line">  Alloc PE / Size       384 / 6.00 GiB</span><br><span class="line">  Free  PE / Size       576 / 9.00 GiB</span><br><span class="line">  VG UUID               35tmMm-Hyec-i4f1-xkd7-pMRS-RgRl-sqFa7l</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>扩容ftpdata,当我们文件不段增加的时候,扩容就很有必要了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan ftpdata]# lvextend -L +4G /dev/vg6/ftpdata</span><br><span class="line"></span><br><span class="line">或者使用,就是想让你明白-L 和 -L +的区别,-L 后面直接加容量,是指直接加到容量,而-L +容量,是指在原有容量上加多少容量!</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# lvextend -L 10G /dev/vg6/ftpdata</span><br><span class="line">  Extending logical volume ftpdata to 10.00 GiB</span><br><span class="line">  Logical volume ftpdata successfully resized</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Name                /dev/vg6/ftpdata</span><br><span class="line">  VG Name                vg6</span><br><span class="line">  LV UUID                LSOtbB-k3mz-DVbb-ATcE-IhBk-V9B7-uaSStM</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                10.00 GiB</span><br><span class="line">  Current LE             640</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# df -h|grep ftpdata</span><br><span class="line">/dev/mapper/vg6-ftpdata</span><br><span class="line">                      6.0G  145M  5.5G   3% /ftpdata</span><br><span class="line"></span><br><span class="line">此时查看ftpdata文件系统容量的时候,还是之前的大小,所以需要resize2fs</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# resize2fs /dev/vg6/ftpdata</span><br><span class="line">resize2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem at /dev/vg6/ftpdata is mounted on /ftpdata; on-line resizing required</span><br><span class="line">old desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">Performing an on-line resize of /dev/vg6/ftpdata to 2621440 (4k) blocks.</span><br><span class="line">The filesystem on /dev/vg6/ftpdata is now 2621440 blocks long.</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# df -h|grep ftpdata</span><br><span class="line">/dev/mapper/vg6-ftpdata</span><br><span class="line">                      9.9G  147M  9.3G   2% /ftpdata</span><br><span class="line"></span><br><span class="line">[root@yangcan ftpdata]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Name                /dev/vg6/ftpdata</span><br><span class="line">  VG Name                vg6</span><br><span class="line">  LV UUID                LSOtbB-k3mz-DVbb-ATcE-IhBk-V9B7-uaSStM</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                10.00 GiB</span><br><span class="line">  Current LE             640</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br><span class="line"></span><br><span class="line">现在就文件系统和逻辑卷空间一致了</span><br></pre></td></tr></table></figure>


<h5 id="———–缩容———"><a href="#———–缩容———" class="headerlink" title="———–缩容———-"></a>———–缩容———-</h5><p>扩容实验做完了,接下来做缩容,缩容比扩容复杂,平时工作也不能轻易的指定缩容的大小.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan ftpdata]# cd ..</span><br><span class="line">[root@yangcan /]# umount /ftpdata/</span><br><span class="line">[root@yangcan /]# e2fsck -f /dev/vg6/ftpdata</span><br><span class="line">e2fsck 1.41.12 (17-May-2010)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">/dev/vg6/ftpdata: 41/655360 files (0.0% non-contiguous), 78604/2621440 blocks</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:我们大概要缩到6G左右,那我们就不能直接resize2fs 到6G,这样肯定是错误的,因为PE是可以被LVM寻址的最小单元,本次实验PE大小为16M.我们去做缩容的时候,不可能是0.6个PE.所有尤其注意,网上很多资料就是直接指定大小,而没有做测试环节!!!会造成数据的丢失,所以指定大小时,先用lvreduce -t 测试一下.用bc算出6G的位置,到底那个值合适</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[root@yangcan /]# bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&#x27;.</span><br><span class="line">--6000刚好整除16</span><br><span class="line">6000%16</span><br><span class="line">0</span><br><span class="line">--6001除16为1</span><br><span class="line">6001%16</span><br><span class="line">1</span><br><span class="line">5999%16</span><br><span class="line">15</span><br><span class="line">--刚好6000M,取余为0,我们比较一下6001和6000的区别</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvreduce -L 6001M /dev/vg6/ftpdata -t</span><br><span class="line">  Test mode: Metadata will NOT be updated and volumes will not be (de)activated.</span><br><span class="line">  Rounding up size to full physical extent 5.88 GiB</span><br><span class="line">  WARNING: Reducing active logical volume to 5.88 GiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce ftpdata? [y/n]: n</span><br><span class="line">  Logical volume ftpdata NOT reduced</span><br><span class="line">显示了警告信息!</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvreduce -L 6000M /dev/vg6/ftpdata -t</span><br><span class="line">  Test mode: Metadata will NOT be updated and volumes will not be (de)activated.</span><br><span class="line">  WARNING: Reducing active logical volume to 5.86 GiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce ftpdata? [y/n]:</span><br><span class="line"></span><br><span class="line">提示为6000M是,没问题</span><br><span class="line">当-t 测试时,没问题了,那我们就resize2fs了</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# resize2fs /dev/vg6/ftpdata 6000M</span><br><span class="line">resize2fs 1.41.12 (17-May-2010)</span><br><span class="line">Resizing the filesystem on /dev/vg6/ftpdata to 1536000 (4k) blocks.</span><br><span class="line">The filesystem on /dev/vg6/ftpdata is now 1536000 blocks long.</span><br><span class="line">挂载,查看文件系统的大小,为最新的6000M,数据也没有丢失!!</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# mount -a</span><br><span class="line">[root@yangcan /]# df -h</span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2              17G  2.1G   14G  14% /</span><br><span class="line">tmpfs                 504M  264K  504M   1% /dev/shm</span><br><span class="line">/dev/sda1             291M   31M  246M  11% /boot</span><br><span class="line">/dev/sr0              2.9G  2.9G     0 100% /media/cdrom</span><br><span class="line">/dev/mapper/vg6-ftpdata  5.8G  145M  5.4G   3% /ftpdata</span><br><span class="line"></span><br><span class="line">我们用lvdisplay查看一下逻辑卷的大小还是为10G</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Name                /dev/vg6/ftpdata</span><br><span class="line">  VG Name                vg6</span><br><span class="line">  LV UUID                LSOtbB-k3mz-DVbb-ATcE-IhBk-V9B7-uaSStM</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                10.00 GiB</span><br><span class="line">  Current LE             640</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br><span class="line"></span><br><span class="line">所以我们用lvreduce进行调整!</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvreduce -L 6000M /dev/vg6/ftpdata</span><br><span class="line">  WARNING: Reducing active and open logical volume to 5.86 GiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce ftpdata? [y/n]: n</span><br><span class="line">  Logical volume ftpdata NOT reduced</span><br><span class="line"></span><br><span class="line">--提示逻辑卷正在打开,所有我们需要停止逻辑卷,再去调整大小</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvchange -an /dev/vg6/ftpdata</span><br><span class="line">[root@yangcan /]# lvscan</span><br><span class="line">  inactive          &#x27;/dev/vg6/ftpdata&#x27; [10.00 GiB] inherit</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvreduce -L 6000M /dev/vg6/ftpdata</span><br><span class="line">  Reducing logical volume ftpdata to 5.86 GiB</span><br><span class="line">  Logical volume ftpdata successfully resized</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# mount -a</span><br><span class="line">mount: special device /dev/vg6/ftpdata does not exist</span><br><span class="line"></span><br><span class="line">--当我们去挂载的时候,提示没有这个设备.所以需要启用</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# lvchange -ay /dev/vg6/ftpdata</span><br><span class="line">[root@yangcan /]# lvscan</span><br><span class="line">  ACTIVE            &#x27;/dev/vg6/ftpdata&#x27; [5.86 GiB] inherit</span><br><span class="line"></span><br><span class="line">重新挂载,里面的文件还在!</span><br><span class="line"></span><br><span class="line">[root@yangcan /]# mount -a</span><br><span class="line">[root@yangcan /]# cd /ftpdata/</span><br><span class="line">[root@yangcan ftpdata]# ll</span><br><span class="line">total 4996</span><br><span class="line">-rw-r--r--. 1 root root     148 Jul 30 19:37 asound.conf</span><br><span class="line">-rw-r--r--. 1 root root   21214 Jul 30 19:37 dnsmasq.conf</span><br><span class="line">-rw-r--r--. 1 root root     559 Jul 30 19:37 dracut.conf</span><br><span class="line">-rw-r--r--. 1 root root      20 Jul 30 19:37 fprintd.conf</span><br><span class="line">-rw-r--r--. 1 root root       0 Jul 30 19:37 gai.conf</span><br><span class="line">-rw-------. 1 root root     781 Jul 30 19:37 grub.conf</span><br><span class="line">-rw-r--r--. 1 root root       9 Jul 30 19:37 host.conf</span><br><span class="line">-rw-r--r--. 1 root root    5309 Jul 30 19:37 kdump.conf</span><br></pre></td></tr></table></figure>

<p>ps: 你也可以不做-t测试,直接指定大小去缩容,看数据是否还在?</p>
<h5 id="——–移除物理卷——–"><a href="#——–移除物理卷——–" class="headerlink" title="——–移除物理卷——–"></a>——–移除物理卷——–</h5><ul>
<li><p>移除之前,物理卷里面必须没有数据,用下以下命令查看各物理卷的空间大小.计划是否有足够的空间可以被用来移动数据!</p>
<ul>
<li><code>[root@yangcan Desktop]# pvscan</code></li>
</ul>
</li>
<li><p>搬移要移除物理卷的数据到其他空闲且满足大小的物理卷</p>
<ul>
<li><code>[root@yangcan Desktop]# pvmove /dev/sda6 /dev/sda7</code><br>完成之后</li>
</ul>
</li>
<li><p>从卷组移除物理卷</p>
<ul>
<li><code>[root@yangcan Desktop]#vgchange -an vg5</code></li>
<li><code>[root@yangcan Desktop]# vgreduce vg5 /dev/sda6</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lyvivian0077.github.io/2018/08/30/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyvivian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="总有刁民想要害朕">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/30/python/" class="post-title-link" itemprop="url">python</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-30 11:53:20" itemprop="dateCreated datePublished" datetime="2018-08-30T11:53:20+09:00">2018-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 12:58:45" itemprop="dateModified" datetime="2021-06-22T12:58:45+09:00">2021-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/main/" itemprop="url" rel="index"><span itemprop="name">main</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Python-3-那些非常规的技巧"><a href="#Python-3-那些非常规的技巧" class="headerlink" title="Python 3 那些非常规的技巧"></a>Python 3 那些非常规的技巧</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HAZJk4eEJ17tAbNc9ais6g">原文</a></li>
</ul>
<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>你有一个list：bag = [1, 2, 3, 4, 5]</p>
<p>现在你想让所有元素翻倍，让它看起来是这个样子：[2, 4, 6, 8, 10]</p>
<p>大多初学者，根据之前语言的经验会大概这样来做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag = [1, 2, 3, 4, 5]</span><br><span class="line">for i in range(len(bag)):</span><br><span class="line">bag[i] = bag[i] * 2</span><br></pre></td></tr></table></figure>

<p>但是有更好的方法：</p>
<p><code>bag = [elem * 2 for elem in bag]</code></p>
<p>很简洁对不对？这叫做Python的列表推导式。</p>
<p>点击Trey Hunner’s tutorial[1]查看更多关于列表推导式的介绍。</p>
<h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>继续，还是上面的列表。</p>
<p>如果可能尽量避免这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag = [1, 2, 3, 4, 5]</span><br><span class="line">for i in range(len(bag)):</span><br><span class="line">print(bag[i])</span><br></pre></td></tr></table></figure>

<p>取而代之的应该是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag = [1, 2, 3, 4, 5]</span><br><span class="line">for i in bag:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>

<p>如果x是一个列表，你可以对它的元素进行迭代。多数情况下你不需要各元素的索引，但如果你非要这样做，那就用enumerate函数。它像下边的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag = [1, 2, 3, 4, 5]</span><br><span class="line">for index, element in enumerate(bag):</span><br><span class="line">print(index, element)</span><br></pre></td></tr></table></figure>

<p>非常直观明了。</p>
<h3 id="元素互换"><a href="#元素互换" class="headerlink" title="元素互换"></a>元素互换</h3><p>如果你是从java或者C语言转到Python来，可能会习惯于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line"># 交换 a 和 b</span><br><span class="line"></span><br><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>

<p>但Python提供了一个更自然更好的方法！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line"># 交换a 和 b</span><br><span class="line"></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<p>够漂亮吧？</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>假如你要一个是10个整数0的列表，你可能首先想到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag =  </span><br><span class="line">for _ in range(10):</span><br><span class="line">bag.append(0)</span><br></pre></td></tr></table></figure>

<p>换个方式吧：</p>
<p><code>bag = [0] * 10</code></p>
<p>看，多优雅。<br>注意：如果你列表包含了列表，这样做会产生浅拷贝。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bag_of_bags = [[0]] * 5 # [[0], [0], [0], [0], [0]]</span><br><span class="line">bag_of_bags[0][0] = 1 # [[1], [1], [1], [1], [1]]</span><br></pre></td></tr></table></figure>

<p>Oops！所有的列表都改变了，而我们只是想要改变第一个列表。</p>
<p>改一改啦：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bag_of_bags = [[0] for _ in range(5)]</span><br><span class="line"># [[0], [0], [0], [0], [0]]</span><br><span class="line">bag_of_bags[0][0] = 1</span><br><span class="line"># [[1], [0], [0], [0], [0]]</span><br></pre></td></tr></table></figure>

<p>同时记住：</p>
<p>“过早优化是万恶之源”</p>
<p>问问自己，初始化一个列表是必须的吗？</p>
<h3 id="构造字符串"><a href="#构造字符串" class="headerlink" title="构造字符串"></a>构造字符串</h3><p>你会经常需要打印字符串。要是有很多变量，避免下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Raymond&quot;</span><br><span class="line">age = 22</span><br><span class="line">born_in = &quot;Oakland, CA&quot;</span><br><span class="line">string = &quot;Hello my name is &quot; + name + &quot;and I&#x27;m &quot; + str(age) + &quot; years old. I was born in &quot; + born_in + &quot;.&quot;</span><br><span class="line">print(string)</span><br></pre></td></tr></table></figure>

<p>额，这看起来多乱呀？你可以用个漂亮简洁的方法来代替，.format。</p>
<p>这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Raymond&quot;</span><br><span class="line">age = 22</span><br><span class="line">born_in = &quot;Oakland, CA&quot;</span><br><span class="line">string = &quot;Hello my name is &#123;0&#125; and I&#x27;m &#123;1&#125; years old. I was born in &#123;2&#125;.&quot;.format(name, age, born_in)</span><br><span class="line">print(string)</span><br></pre></td></tr></table></figure>

<p>好多了！</p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>Python允许你在一个函数中返回多个元素，这让生活更简单。但是在解包元组的时候出出线这样的常见错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def binary:</span><br><span class="line">return 0, 1</span><br><span class="line">result = binary</span><br><span class="line">zero = result[0]</span><br><span class="line">one = result[1]</span><br></pre></td></tr></table></figure>

<p>这是没必要的，你完全可以换成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def binary:</span><br><span class="line">return 0, 1</span><br><span class="line">zero, one = binary</span><br><span class="line">要是你需要所有的元素被返回，用个下划线_：</span><br><span class="line">zero, _ = binary</span><br></pre></td></tr></table></figure>

<p>就是这么高效率！</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>你也会经常给dicts中写入key，pair（键，值）。</p>
<p>如果你试图访问一个不存在的于dict的key，可能会为了避免KeyError错误，你会倾向于这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">countr = &#123;&#125;</span><br><span class="line">bag = [2, 3, 1, 2, 5, 6, 7, 9, 2, 7]</span><br><span class="line">for i in bag:</span><br><span class="line">    if i in countr:</span><br><span class="line">        countr[i] += 1</span><br><span class="line">    else:</span><br><span class="line">        countr[i] = 1</span><br><span class="line">for i in range(10):</span><br><span class="line">    if i in countr:</span><br><span class="line">        print(&quot;Count of &#123;&#125;: &#123;&#125;&quot;.format(i, countr[i]))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Count of &#123;&#125;: &#123;&#125;&quot;.format(i, 0))</span><br></pre></td></tr></table></figure>

<p>但是，用get是个更好的办法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">countr = &#123;&#125;</span><br><span class="line">bag = [2, 3, 1, 2, 5, 6, 7, 9, 2, 7]</span><br><span class="line">for i in bag:</span><br><span class="line">    countr[i] = countr.get(i, 0) + 1</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(&quot;Count of &#123;&#125;: &#123;&#125;&quot;.format(i, countr.get(i, 0)))</span><br><span class="line"></span><br><span class="line">当然你也可以用setdefault来代替。</span><br></pre></td></tr></table></figure>

<p>这还用一个更简单却多费点开销的办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bag = [2, 3, 1, 2, 5, 6, 7, 9, 2, 7]</span><br><span class="line">countr = dict([(num, bag.count(num)) for num in bag])</span><br><span class="line">for i in range(10):</span><br><span class="line">    print(&quot;Count of &#123;&#125;: &#123;&#125;&quot;.format(i, countr.get(i, 0)))</span><br></pre></td></tr></table></figure>

<p>你也可以用dict推导式。</p>
<p><code>countr = &#123;num: bag.count(num) for num in bag&#125;</code></p>
<p>这两种方法开销大是因为它们在每次count被调用时都会对列表遍历。</p>
<h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>现有的库只需导入你就可以做你真正想做的了。</p>
<p>还是说前面的例子，我们建一个函数来数一个数字在列表中出现的次数。那么，已经有一个库就可以做这样的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">bag = [2, 3, 1, 2, 5, 6, 7, 9, 2, 7]</span><br><span class="line">countr = Counter(bag)</span><br><span class="line">for i in range(10):</span><br><span class="line">print(&quot;Count of &#123;&#125;: &#123;&#125;&quot;.format(i, countr[i]))</span><br></pre></td></tr></table></figure>

<p>一些用库的理由：</p>
<p>代码是正确而且经过测试的。</p>
<p>它们的算法可能会是最优的，这样就跑的更快。</p>
<p>抽象化：它们指向明确而且文档友好，你可以专注于那些还没有被实现的。</p>
<p>最后，它都已经在那儿了，你不用再造轮子了。</p>
<h3 id="在列表中切片-步进"><a href="#在列表中切片-步进" class="headerlink" title="在列表中切片/步进"></a>在列表中切片/步进</h3><p>你可以指定start的点和stop点，就像这样list[start:stop:step]。我们取出列表中的前5个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bag = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">for elem in bag[:5]:</span><br><span class="line">print(elem)</span><br></pre></td></tr></table></figure>

<p>这就是切片，我们指定stop点是5，再停止前就会从列表中取出5个元素。</p>
<p>要是最后5个元素怎么做？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bag = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">for elem in bag[-5:]:</span><br><span class="line">print(elem)</span><br></pre></td></tr></table></figure>

<p>没看明白吗？-5意味着从列表的结尾取出5个元素。</p>
<p>如果你想对列表中元素间隔操作，你可能会这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bag = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">for index, elem in enumerate(bag):</span><br><span class="line">if index % 2 == 0:</span><br><span class="line">print(elem)</span><br></pre></td></tr></table></figure>

<p>但是你应该这样来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bag = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">for elem in bag[::2]:</span><br><span class="line">print(elem)</span><br><span class="line"></span><br><span class="line"># 或者用 ranges</span><br><span class="line"></span><br><span class="line">bag = list(range(0,10,2))</span><br><span class="line">print(bag)</span><br></pre></td></tr></table></figure>

<p>这就是列表中的步进。list[::2]意思是遍历列表同时两步取出一个元素。</p>
<p>你可以用list[::-1]很酷的翻转列表。</p>
<h3 id="tab键还是空格键"><a href="#tab键还是空格键" class="headerlink" title="tab键还是空格键"></a>tab键还是空格键</h3><p>长时间来看，将tab和空格混在一起会造成灾难，你会看到IndentationError: unexpected indent。不管你选择tab键还是空格键，你应该在你的文件和项目中一直保持使用。</p>
<p>一个使用空格而不是tab的原因是，tab不是在所有编辑器中都一样的。视呢所用的编辑器，tab可能会被当作2到8个空格。</p>
<p>你也可以在写代码时用空格来定义tab。这样你可以自己选择用几个空格来当做tab。大多数Python用户是用4个空格。</p>
<h2 id="for文処理が1行で書ける！素敵なリスト内包表記"><a href="#for文処理が1行で書ける！素敵なリスト内包表記" class="headerlink" title="for文処理が1行で書ける！素敵なリスト内包表記"></a>for文処理が1行で書ける！素敵なリスト内包表記</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.yoheim.net/blog.php?q=20150702">原文</a></li>
</ul>
<h4 id="1行で書くリスト処理"><a href="#1行で書くリスト処理" class="headerlink" title="1行で書くリスト処理"></a>1行で書くリスト処理</h4><p>さっそくリスト内包記述（list comprehension）を扱いたいと思います。今回は以下の配列データを扱うこととします。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = [1, 2, 3, 4, 5] この配列について、各要素の値を2倍にする処理を通常のfor文で記述すると、以下のようになります。</span><br></pre></td></tr></table></figure>

<h4 id="data配列の中身を2倍にする"><a href="#data配列の中身を2倍にする" class="headerlink" title="data配列の中身を2倍にする"></a>data配列の中身を2倍にする</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newData = []</span><br><span class="line">for d in data:</span><br><span class="line">  newData.append(d * 2)</span><br></pre></td></tr></table></figure>

<p>この3行の実装を、リスト内包表記で記述すると1行で記述することができます。素敵！</p>
<h4 id="data配列の中身を2倍にする-1"><a href="#data配列の中身を2倍にする-1" class="headerlink" title="data配列の中身を2倍にする"></a>data配列の中身を2倍にする</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newData = [d * 2 for d in data] </span><br></pre></td></tr></table></figure>

<p>この書き方はシンプルだし直感的に理解できるので、なかなか便利です。</p>
<h3 id="1行で書くリスト処理（if文付き）"><a href="#1行で書くリスト処理（if文付き）" class="headerlink" title="1行で書くリスト処理（if文付き）"></a>1行で書くリスト処理（if文付き）</h3><p>さらに、処理の中で条件式（if文）を記述することもできます。例えば偶数のみ処理したい場合に、通常の書き方では以下のように記述します。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newData = []</span><br><span class="line">for d in data:</span><br><span class="line">    if d % 2 == 0:</span><br><span class="line">        newData.append(d * 2)</span><br></pre></td></tr></table></figure>

<p>上記の場合には4行の実装ですが、リスト内包表記だと以下のように1行で記述することができます。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newData = [d * 2 for d in data if d % 2 == 0]</span><br></pre></td></tr></table></figure>

<p>オライリーの本やWeb上のサンプルコードでも良く見る記述なので、この記述は読み書きできる必要がありそうです。</p>
<h3 id="ラムダ式＋filterで同じことを実現できる"><a href="#ラムダ式＋filterで同じことを実現できる" class="headerlink" title="ラムダ式＋filterで同じことを実現できる"></a>ラムダ式＋filterで同じことを実現できる</h3><p>ラムダ式でもリスト内包表記と同じように、1行で処理を記述することができます。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newData = []</span><br><span class="line">for d in data:</span><br><span class="line">    if d % 2 == 0:</span><br><span class="line">        newData.append(d)</span><br></pre></td></tr></table></figure>

<p>これをラムダ式で書くと以下のようになります。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newData = filter(lambda x:x%2==0, data)</span><br></pre></td></tr></table></figure>

<p>この記述もなかなか良さそうですね！ただラムダ式の場合には、filterした後に演算を行う（例：値を2倍にする）ことができないので、リスト内包表記の方がより柔軟に記述できます。</p>
<h3 id="リスト内包表記はパフォーマンスも良い"><a href="#リスト内包表記はパフォーマンスも良い" class="headerlink" title="リスト内包表記はパフォーマンスも良い"></a>リスト内包表記はパフォーマンスも良い</h3><p>通常のfor文を書くよりも、リスト内包表記の方がパフォーマンスが良いです。いくつか調べた情報によると、リスト内包表記でfor処理すれば、記述した文法をC言語レベルで処理するため速いとのこと。実際に試してみました。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 利用するデータ</span><br><span class="line">data = [i for i in range(1, 1000000)]</span><br><span class="line"></span><br><span class="line"># 通常のfor文</span><br><span class="line">time1 = time.clock()</span><br><span class="line">newData = []</span><br><span class="line">for d in data:</span><br><span class="line">    if d % 2 == 0:</span><br><span class="line">        newData.append(d)</span><br><span class="line">time2 = time.clock()</span><br><span class="line">print time2 - time1 #0.234422秒</span><br><span class="line"></span><br><span class="line"># リスト内包表記    </span><br><span class="line">time1 = time.clock()</span><br><span class="line">newData = [d for d in data if d % 2 == 0]</span><br><span class="line">time2 = time.clock()</span><br><span class="line">print time2 - time1 #0.185301秒</span><br><span class="line"></span><br><span class="line"># filterとラムダ式</span><br><span class="line">time1 = time.clock()</span><br><span class="line">newData = filter(lambda x:x%2==0, data)</span><br><span class="line">time2 = time.clock()</span><br><span class="line">print time2 - time1 #0.184838</span><br></pre></td></tr></table></figure>

<p>何度か試したところ、上記例の場合には、リスト内包表記は通常のfor文記述よりも22％高速でした（僕のMacBookAirの場合）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyvivian</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
