<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Re 模块 - 总有刁民想要害朕</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Re \u6a21\u5757";
        var mkdocs_page_input_path = "Python-Re-\u6a21\u5757\u8d85\u5168\u89e3\u8bfb.markdown";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QXRGWVKZW2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QXRGWVKZW2');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 总有刁民想要害朕
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">ansbile</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile/">ansbileオプション</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ansbile_async/">ansbile_async</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../awk/">awk</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sed/">sed</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../MB-MiB%E7%9A%84%E5%8C%BA%E5%88%AB/">MB_MiB的区别</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">MegaRAID</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../megacli/">megacli</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../megaraid/">megaraid</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MySQL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Explain详解与索引最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql/">Mysql参数优化</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql-table/">MySQL-table</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql%E3%82%92%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/">MySQLビルド</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mysql-ha/">mysql+keepalived搭建教程</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python Tips</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../python-styleguide/">Python风格规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-config/">Python程序配置文件管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-decorator/">装饰器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-dunder/">5种下划线</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-function/">传入参数的几种方法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python/">非常规的技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../python-mysql/">操作mysql基础</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Re 模块</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#compilepattern">compile(pattern)：创建模式对象</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#searchpatternstring">search(pattern,string)：在字符串中寻找模式</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#matchpatternstring">match(pattern,string)：在字符串开始处匹配模式</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">等价于</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#if">上面的函数返回都可以在if条件语句中进行判断：</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#splitpatternstring">split(pattern,string)：根据模式分割字符串,返回列表</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#findallpatternstring">findall(pattern,string)：列表形式返回匹配项</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#subpatreplstring-repl-pat">sub(pat,repl,string) ：用repl替换 pat匹配项</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#escapestring">escape(string) ：对字符串里面的特殊字符串进行转义</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/">字符串拼接总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C/">代码并行</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Regular-Expression/">正規表現</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../taged-VLAN%E3%81%A8untagedVLAN%E3%81%AE%E9%81%95%E3%81%84/">タグVLAN</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sar/">sar</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Bash%E7%BC%96%E7%A8%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/">Bash编程超详细语法总结</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../iptables/">iptables</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../linux-lvm/">linux-lvm</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos7-set-kernel/">centos7-set-kernel</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../centos-network-device-naming/">centos-network-device-naming</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-Performance/">Linux Performance</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Linux-shell-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">Linux-shell-逻辑运算符-逻辑表达式详解</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8ALVM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">LVM逻辑卷基本概念及LVM的工作原理</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../macOS%E8%BD%AF%E4%BB%B6%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E6%9B%B4%E6%96%B010-15/">macOS软件编译时找不到头文件解决方法[更新10.15]</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ubnt/">ubnt</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vim/">VIM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">总有刁民想要害朕</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>Python Tips &raquo;</li>
      <li>Re 模块</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h3 id="re">re模块下的函数<a class="headerlink" href="#re" title="Permanent link">&para;</a></h3>
<h4 id="compilepattern">compile(pattern)：创建模式对象<a class="headerlink" href="#compilepattern" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">import re
pat=re.compile('A')
m=pat.search('CBA')                    #等价于 re.search('A','CBA')
print m
&lt;_sre.SRE_Match object at 0x9d690c8&gt;   #匹配到了，返回MatchObject（True）

m=pat.search('CBD')
print m
None                                   #没有匹配到，返回None（False）
</code></pre>
<h4 id="searchpatternstring">search(pattern,string)：在字符串中寻找模式<a class="headerlink" href="#searchpatternstring" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">m = re.search('asd','ASDasd')
print m
&lt;_sre.SRE_Match object at 0xb72cd6e8&gt;  #匹配到了，返回MatchObject（True）
m = re.search('asd','ASDASD')
print m
None                                   #没有匹配到，返回None（False）
</code></pre>
<h4 id="matchpatternstring">match(pattern,string)：在字符串开始处匹配模式<a class="headerlink" href="#matchpatternstring" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">m = re.search('asd','ASDasd')
print m
&lt;_sre.SRE_Match object at 0xb72cd6e8&gt;  #匹配到了，返回MatchObject（True）
m = re.search('asd','ASDASD')
print m
None                                   #没有匹配到，返回None（False）
</code></pre>
<h5 id="_1">等价于<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h5>
<pre><code class="language-python">pat=re.compile('a')
print pat.match('Aasd')
None
printpat.match('aASD')
&lt;_sre.SRE_Match object at 0xb72cd6e8&gt;
</code></pre>
<h5 id="if">上面的函数返回都可以在if条件语句中进行判断：<a class="headerlink" href="#if" title="Permanent link">&para;</a></h5>
<pre><code class="language-python">if pat.search('asd'):
...     print 'OK'
...
OK        #找到返回
if re.search('a','ASD'):
...     print &quot;OK&quot;
...       #没有找到
</code></pre>
<h4 id="splitpatternstring">split(pattern,string)：根据模式分割字符串,返回列表<a class="headerlink" href="#splitpatternstring" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">re.split(',','a,s,d,asd')
['a', 's', 'd', 'asd']          #返回列表

pat = re.compile(',')
pat.split('a,s,d,asd')
['a', 's', 'd', 'asd']          #返回列表

re.split('[, ]+','a ,  s  ,d     ,,,,,asd')   #正则匹配：[, ]+，后面说明
['a', 's', 'd', 'asd']

re.split('[, ]+','a ,  s  ,d     ,,,,,asd',maxsplit=2) # maxsplit 最多分割次数
['a', 's', 'd     ,,,,,asd']

pat = re.compile('[, ]+')                     #正则匹配：[, ]+，后面说明
pat.split('a ,  s  ,d     ,,,,,asd',maxsplit=2)        # maxsplit 最多分割次数
['a', 's', 'd     ,,,,,asd']
</code></pre>
<h4 id="findallpatternstring">findall(pattern,string)：列表形式返回匹配项<a class="headerlink" href="#findallpatternstring" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">re.findall('a','ASDaDFGAa')
['a', 'a']                           #列表形式返回匹配到的字符串

pat = re.compile('a')
pat.findall('ASDaDFGAa')
['a', 'a']                           #列表形式返回匹配到的字符串

pat = re.compile('[A-Z]+')       #正则匹配：'[A-Z]+' 后面有说明
pat.findall('ASDcDFGAa')
['ASD', 'DFGA']                      #找到匹配到的字符串

pat = re.compile('[A-Z]')
pat.findall('ASDcDFGAa')         #正则匹配：'[A-Z]+' 后面有说明
['A', 'S', 'D', 'D', 'F', 'G', 'A']  #找到匹配到的字符串

pat = re.compile('[A-Za-z]')     #正则匹配：'[A-Za-z]+' 匹配所有单词，后面有说明
pat.findall('ASDcDFGAa')
['A', 'S', 'D', 'c', 'D', 'F', 'G', 'A', 'a']
</code></pre>
<h4 id="subpatreplstring-repl-pat">sub(pat,repl,string) ：用repl替换 pat匹配项<a class="headerlink" href="#subpatreplstring-repl-pat" title="Permanent link">&para;</a></h4>
<p>(留的是中间的，因为中间在中心)</p>
<pre><code class="language-python">re.sub('a','A','abcasd')   #找到a用A替换，后面见和group的配合使用
'AbcAsd'

pat = re.compile('a')
pat.sub('A','abcasd')
'AbcAsd'

pat=re.compile(r'www\.(.*)\..{3}') #正则表达式
  #在Python的string前面加上‘r’， 是为了告诉编译器这个string是个raw string，不要转译反斜杠 '\' 。
  #例如，\n 在raw string中，是两个字符，\和n， 而不会转译为换行符。
  #由于正则表达式和 \ 会有冲突，因此，当一个字符串使用了正则表达式后，最好在前面加上'r'。

  #与大多数编程语言相同，正则表达式里使用&quot;\&quot;作为转义字符，这就可能造成反斜杠困扰。
  #假如你需要匹配文本中的字符&quot;\&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠&quot;\\\\&quot;：
  #前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。
  #Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&quot;\\&quot;表示。
  #同样，匹配一个数字的&quot;\\d&quot;可以写成r&quot;\d&quot;。
  #有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。

  #不是说 加了r \就没有转译功能，好乱，就直接记住1句话：
  #当一个字符串使用了正则表达式后，最好在前面加上'r'，这样你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观

pat.match('www.dxy.com').group(1)
'dxy'

re.sub(r'www\.(.*)\..{3}',r'\1','hello,www.dxy.com')

pat.sub(r'\1','hello,www.dxy.com')
'hello,dxy'
# r'1' 是第一组的意思
#通过正则匹配找到符合规则的&quot;www.dxy.com&quot; ，取得 组1字符串 去替换 整个匹配。


pat=re.compile(r'(\w+) (\w+)')     #正则表达式
s='hello world ! hello hz !'

pat.findall('hello world ! hello hz !')
[('hello', 'world'), ('hello', 'hz')]
pat.sub(r'\2 \1',s)                #通过正则得到组1(hello)，组2(world)，再通过sub去替换。即组1替换组2，组2替换组1，调换位置。  
'world hello!hz hello!'
</code></pre>
<h4 id="escapestring">escape(string) ：对字符串里面的特殊字符串进行转义<a class="headerlink" href="#escapestring" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">re.escape('www.dxy.cn')
'www\\.dxy\\.cn'                   #转义
</code></pre>
<p>上面的函数中，只有match、search有group方法，其他的函数没有。</p>
<h3 id="_2">函数的方法<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<h4 id="group">group：获取子模式(组)的匹配项<a class="headerlink" href="#group" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">pat = re.compile(r'www\.(.*)\.(.*)')       #用()表示1个组，2个组
m = pat.match('www.dxy.com')
m.group()                                  #默认为0，表示匹配整个字符串  
'www.dxy.com'

m.group(1)                                 #返回给定组1匹配的子字符串
'dxy'

m.group(2)
'com'
</code></pre>
<h4 id="start">start：给定组匹配项的开始位置<a class="headerlink" href="#start" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">m.start(2)                                 #组2开始的索引
8
</code></pre>
<h4 id="end">end：给定组匹配项的结束位置<a class="headerlink" href="#end" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">m.end(2)                                   #组2结束的索引
11
</code></pre>
<h4 id="span">span： 给定组匹配项的开始结束位置<a class="headerlink" href="#span" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">m.span(2)                                  #组2开始、结束的索引
(8, 11)
</code></pre>
<h3 id="_3">正则表达式<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<h4 id="_4">元字符<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<h4 id="1">“.” ：通配符,除换行符外的任意的1个字符<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">pat=re.compile('.')
pat.match('abc')
&lt;_sre.SRE_Match object at 0xb72b6170&gt;
pat.match('abc').group()
'a'                                #匹配到了首个字符
pat.search('abc').group()
'a'
pat.match('\n').group()        #换行符匹配出错
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<h4 id="_5">“\” : 转义符<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">pat=re.compile('\.')
pat.search('abc.efg').group()  #匹配到.
'.'
pat.findall('abc.efg')         #不用group,返回列表
['.']
</code></pre>
<h4 id="_6">“[…]” : 字符集合，匹配里面的任意一个元素<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('[abc]')
&gt;&gt;&gt; pat.match('axbycz').group()
'a'
&gt;&gt;&gt; pat.search('axbycz').group()
'a'
&gt;&gt;&gt; pat.findall('axbycz')
['a', 'b', 'c']
</code></pre>
<h4 id="d">“\d” : 数字<a class="headerlink" href="#d" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\d')          
&gt;&gt;&gt; pat.search('ax1by2cz3').group()   #匹配到第一个数字:1，返回
'1'

&gt;&gt;&gt; pat.match('ax1by2cz3').group()    #匹配不到（首个不是）返回None，报错，match匹配字符串头
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'

&gt;&gt;&gt; pat.findall('ax1by2cz3')          #匹配所有的数字，列表返回
['1', '2', '3']
</code></pre>
<h4 id="d_1">“\D” : 非数字<a class="headerlink" href="#d_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\D')
&gt;&gt;&gt; pat.match('ax1by2cz3').group()
'a'
&gt;&gt;&gt; pat.search('ax1by2cz3').group()
'a'
&gt;&gt;&gt; pat.findall('ax1by2cz3')
['a', 'x', 'b', 'y', 'c', 'z']
</code></pre>
<h4 id="s-trn">“\s” ：空白字符 、 \t、\r、\n、空格<a class="headerlink" href="#s-trn" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\s')
&gt;&gt;&gt; pat.findall('\rax1 \nby2 \tcz3')
['\r', ' ', '\n', ' ', '\t']
&gt;&gt;&gt; pat.search('\rax1 \nby2 \tcz3').group()
'\r'
&gt;&gt;&gt; pat.match('\rax1 \nby2 \tcz3').group()
'\r'
</code></pre>
<h4 id="s">“S” :非空白字符<a class="headerlink" href="#s" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\S')
&gt;&gt;&gt; pat.search('\rax1 \nby2 \tcz3').group()
'a'
&gt;&gt;&gt; pat.findall('\rax1 \nby2 \tcz3')
['a', 'x', '1', 'b', 'y', '2', 'c', 'z', '3']
</code></pre>
<h4 id="w-a-za-z0-9">“\w” ：单个的 数字和字母，[A-Za-z0-9]<a class="headerlink" href="#w-a-za-z0-9" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\w')
&gt;&gt;&gt; pat.search('1a2b3c').group()
'1'
&gt;&gt;&gt; pat.findall('1a2b3c')
['1', 'a', '2', 'b', '3', 'c']
&gt;&gt;&gt; pat.match('1a2b3c').group()
'1'
</code></pre>
<h4 id="w">“\W”:非单词字符,除数字和字母外<a class="headerlink" href="#w" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile('\W')
&gt;&gt;&gt; pat.findall('1a2我b3c') #python是用三字节表示一个汉字
['\xe6', '\x88', '\x91']
&gt;&gt;&gt; pat.search('1a2我b3c').group()
'\xe6'
</code></pre>
<h3 id="_7">数量词<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<h4 id="0">“*” ：0次或多次<a class="headerlink" href="#0" title="Permanent link">&para;</a></h4>
<p>（ 乘0会变成0）</p>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]*')
&gt;&gt;&gt; pat.match('abcabcdefabc').group()
'abcabc'                              #2次
&gt;&gt;&gt; pat.search('abcabcdefabc').group()
'abcabc'                              #2次
&gt;&gt;&gt; pat.findall('abcabcdefabc')
['abcabc', '', '', '', 'abc', '']     #2次和1次,因为有0次，所以匹配了''
</code></pre>
<h4 id="1_1">“+” ：1次或多次<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h4>
<p>（ 加0不会变成0）</p>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]+')
&gt;&gt;&gt; pat.match('abcdefabcabc').group()
'abc'
&gt;&gt;&gt; pat.search('abcdefabcabc').group()
'abc'
&gt;&gt;&gt; pat.findall('abcdefabcabc')
['abc', 'abcabc']
</code></pre>
<h4 id="01matchsearch-none-0">“?” ：0次或1次，match,search 不会出现none，会出现’ ‘ （因为0次也是符合的）<a class="headerlink" href="#01matchsearch-none-0" title="Permanent link">&para;</a></h4>
<p>0次或1次不是指<code>[xxx]</code>这个集合，而是其中的任何的一个字符</p>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]?')
&gt;&gt;&gt; pat.match('defabc').group()     #0次
''
&gt;&gt;&gt; pat.match('abcdefabc').group()
'a'
&gt;&gt;&gt; pat.search('defabc').group()    #0次
''
&gt;&gt;&gt; pat.findall('defabc')           #0次和1次
['', '', '', 'a', 'b', 'c', '']     #后面总再加个''
</code></pre>
<h4 id="_8">“数量词?” ：非贪婪模式：只匹配最少的（尽可能少）；默认贪婪模式：匹配最多的（尽可能多）<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]+')         #贪婪模式
&gt;&gt;&gt; pat.match('abcdefabcabc').group()  #匹配尽可能多的：abc
'abc'
&gt;&gt;&gt; pat.match('bbabcdefabcabc').group()
'bbabc'
&gt;&gt;&gt; pat.search('dbbabcdefabcabc').group()
'bbabc'
&gt;&gt;&gt; pat.findall('abcdefabcabc')
['abc', 'abcabc']

&gt;&gt;&gt; pat = re.compile('[abc]+?')        #非贪婪模式：+?
&gt;&gt;&gt; pat.match('abcdefabcabc').group()  #匹配尽可能少的：a、b、c
'a'
&gt;&gt;&gt; pat.search('dbbabcdefabcabc').group()
'b'
&gt;&gt;&gt; pat.findall('abcdefabcabc')
['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']
</code></pre>
<h4 id="m-m">“{m}” ：匹配字符串出现m次<a class="headerlink" href="#m-m" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[op]{2}')     #o或p出现2次
&gt;&gt;&gt; pat.search('abcooapp').group()  #匹配第一次出现的字符串,o比p先出现
'oo'
&gt;&gt;&gt; pat.findall('abcooapp')         #匹配出现的所有字符串，列表形式返回
['oo', 'pp']
</code></pre>
<h4 id="mn-mn">“{m,n}” ：匹配字符串出现m到n次<a class="headerlink" href="#mn-mn" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[op]{2,4}')     #o或则p出现2到4次
&gt;&gt;&gt; pat.match('pppabcooapp').group()  #匹配开头
'ppp'
&gt;&gt;&gt; pat.search('pppabcooapp').group() #匹配第一次出现
'ppp'
&gt;&gt;&gt; pat.findall('pppabcooapp')        #匹配所有
['ppp', 'oo', 'pp']
</code></pre>
<h3 id="group_1">.group() #匹配第一次出现<a class="headerlink" href="#group_1" title="Permanent link">&para;</a></h3>
<h4 id="_9">边界<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<h4 id="_10">“^” ：匹配字符串开头或行头<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('^[abc]')     #开头是a、b、c中的任意一个
&gt;&gt;&gt; pat.search('defabc').group()    
&gt;&gt;&gt; pat.match('defabc').group()    #均找不到
&gt;&gt;&gt; pat.findall('defabc')
[]

&gt;&gt;&gt; pat.search('adefabc').group()
'a'
&gt;&gt;&gt; pat.match('adefabc').group()   #开头是a、b、c中的任意一个
'a'
&gt;&gt;&gt; pat.findall('adefabc')
['a']

&gt;&gt;&gt; pat = re.compile('^[abc]+')    #开头是a、b、c中的任意一个的一次或则多次，贪婪：匹配多个
&gt;&gt;&gt; pat.findall('cbadefab')
['cba']
&gt;&gt;&gt; pat = re.compile(r'^[abc]+?')  #开头是a、b、c中的任意一个的一次或则多次，非贪婪：匹配一个
&gt;&gt;&gt; pat.findall('cbadefab')
['c']
</code></pre>
<h4 id="_11">“$” ：匹配字符串结尾或则行尾<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]$')
&gt;&gt;&gt; pat.match('adefAbc').group()   #match匹配的是字符串开头，所以查找$的时，总是返回None
&gt;&gt;&gt; pat.search('adefAbc').group()  #结尾是a、b、c中的任意一个
'c'
&gt;&gt;&gt; pat.findall('adefAbc')        
['c']
&gt;&gt;&gt; pat = re.compile('[abc]+$')
&gt;&gt;&gt; pat.search('adefAbc').group()  #结尾是a、b、c中的任意一个的一次或则多次，贪婪：匹配多个
'bc'
&gt;&gt;&gt; pat.findall('adefAbc')
['bc']
</code></pre>
<h4 id="a">“\A”：匹配字符串开头<a class="headerlink" href="#a" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('\A[abc]+')
&gt;&gt;&gt; pat.findall('cbadefab')
['cba']
&gt;&gt;&gt; pat.search('cbadefab').group()
'cba'
</code></pre>
<h4 id="z">“\Z”：匹配字符串结尾<a class="headerlink" href="#z" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat = re.compile('[abc]+\Z')
&gt;&gt;&gt; pat.search('cbadefab').group()
'ab'
&gt;&gt;&gt; pat.findall('cbadefab')
['ab']
</code></pre>
<h3 id="_12">分组<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<h4 id="1_2">(…)：分组匹配,从左到右,每遇到一个 ( 编号+1，分组后面可加数量词<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(a)\w(c)')  #\w:单个的数字或字母 [A-Za-z0-9]
&gt;&gt;&gt; pat.match('abcdef').group()
'abc'
&gt;&gt;&gt; pat=re.compile('(a)b(c)')    #分2组，匿名分组

&gt;&gt;&gt; pat.match('abcdef').group()  #默认返回匹配的字符串
'abc'
&gt;&gt;&gt; pat.match('abcdef').group(1) #取分组1，适用于search
'a'
&gt;&gt;&gt; pat.match('abcdef').group(2) #取分组2，适用于search
'c'
&gt;&gt;&gt; pat.match('abcdef').groups() #取所有分组，元组形式返回
('a', 'c')
</code></pre>
<h4 id="_13"><number>：引用编号为<number>的分组匹配到的字符串<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'www\.(.*)\..{3}')
&gt;&gt;&gt; pat.match('www.dxy.com').group(1)
'dxy'
</code></pre>
<h4 id="p">“(?P<name>…)” ：在模式里面用()来表示分组（命名分组）,适用于提取目标字符串中的某一些部位。<a class="headerlink" href="#p" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(?P&lt;K&gt;a)\w(c)')    #分2组：命名分组+匿名分组
&gt;&gt;&gt; pat.search('abcdef').groups()       #取所有分组，元组形式返回
('a', 'c')
&gt;&gt;&gt; pat.search('abcdef').group(1)       #取分组1，适用于match
'a'
&gt;&gt;&gt; pat.search('abcdef').group(2)       #取分组2，适用于match
'c'
&gt;&gt;&gt; pat.search('abcdef').group()        #默认返回匹配的字符串
'abc'
&gt;&gt;&gt; pat.search('abcdef').groupdict()    #命名分组可以返回一个字典【专有】，匿名分组也没有
{'K': 'a'}
</code></pre>
<h4 id="pname">“(?P=name)”：引用别名为<name>的分组匹配到的串<a class="headerlink" href="#pname" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(?P&lt;K&gt;a)\w(c)(?P=K)')    #(?P=K)引用分组1的值，就是a
&gt;&gt;&gt; pat.search('abcdef').group()              #匹配不到，因为完整'a\wca',模式的第4位是a
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'

&gt;&gt;&gt; pat.search('abcadef').group()             #匹配到，模式的第4位和组1一样,值是c
'abca'
&gt;&gt;&gt; pat.search('abcadef').groups()
('a', 'c')
&gt;&gt;&gt; pat.search('abcadef').group(1)
'a'
&gt;&gt;&gt; pat.search('abcadef').group(2)
'c
</code></pre>
<h4 id="_14">“<number>” ：引用分组编号匹配：<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(?P&lt;K&gt;a)\w(c)(?P=K)\2')  #\2引用分组2的值，就是c
&gt;&gt;&gt; pat.findall('Aabcadef')                   #匹配不到，因为完整'a\wcac',模式的第5位是c
[]
&gt;&gt;&gt; pat.findall('Aabcacdef')                  #匹配到，模式的第5位和组2一样,值是c
[('a', 'c')]
&gt;&gt;&gt; pat.search('Aabcacdef').groups()
('a', 'c')
&gt;&gt;&gt; pat.search('Aabcacdef').group()
'abcac'
&gt;&gt;&gt; pat.search('Aabcacdef').group(1)
'a'
&gt;&gt;&gt; pat.search('Aabcacdef').group(2)
'c'
</code></pre>
<h4 id="_15">特殊构造<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li><code>(?:…) (…)</code>不分组版本,用于使用 <code>|</code> 或者后接数量词</li>
<li><code>(?iLmsux)</code> iLmsux的每个字符代表一个匹配模式,只能用在正则表达式的开头,可选多个</li>
<li><code>(?#…)</code> #号后的内容将作为注释</li>
<li><code>(?=…)</code> 之后的字符串内容需要匹配表达式才能成功匹配</li>
<li><code>(?!…)</code> 之后的字符串不匹配表达式才能成功</li>
<li><code>(?(?(?(id/name) yes |no)</code> 如果编号为id/名字为name的组匹配到字符串,则需要匹配yes,否则匹配no,no可以省略</li>
</ul>
<h4 id="_16">“(?:…)” ：()里面有?:表示该()不是分组<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'a(?:bc)')
&gt;&gt;&gt; pat.findall('abc')
['abc']
&gt;&gt;&gt; pat.match('abc').groups()      #显示不出分组
</code></pre>
<h4 id="_17">“(?=…)”：匹配…表达式，返回。对后进行匹配，总是对后面进行匹配<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'\w(?=\d)')    #匹配表达式\d，返回数字的前一位，\w：单词字符[A-Za-z0-9]
&gt;&gt;&gt; pat.findall('abc1 def1 xyz1')
['c', 'f', 'z']
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou')  #匹配数字的前一位，列表返回
['y', '2', '0', '1', '3', '0', '6', '2']
&gt;&gt;&gt; pat=re.compile(r'\w+(?=\d)')
&gt;&gt;&gt; pat.findall('abc1,def1,xyz1')          #匹配最末数字的前字符串，列表返回
['abc', 'def', 'xyz']
&gt;&gt;&gt; pat.findall('abc21,def31,xyz41')
['abc2', 'def3', 'xyz4']
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou')
['zhoujy2013062']
&gt;&gt;&gt; pat=re.compile(r'[A-Za-z]+(?=\d)')       #[A-Za-z],匹配字母,可以用其他的正则方法
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou123') #匹配后面带有数字的字符串，列表返回
['zhoujy', 'hangzhou']
&gt;&gt;&gt; pat.findall('abc21,def31,xyz41')
['abc', 'def', 'xyz']
</code></pre>
<h4 id="_18">“(?!…)” 不匹配…表达式，返回。对后进行匹配<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'[A-Za-z]+(?!\d)')       #[A-Za-z],匹配字母,可以用其他的正则方法
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou123,12,binjiang310')  #匹配后面不是数字的字符串，列表返回
['zhouj', 'hangzho', 'binjian']
&gt;&gt;&gt; pat.findall('abc21,def31,xyz41')
['ab', 'de', 'xy']
</code></pre>
<h4 id="_19">“(?&lt;=…)”：匹配…表达式，返回。对前进行匹配,总是对前面进行匹配<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(?&lt;=\d)[A-Za-z]+')      #匹配前面是数字的字母
&gt;&gt;&gt; pat.findall('abc21,def31,xyz41')
[]
&gt;&gt;&gt; pat.findall('1abc21,2def31,3xyz41')
['abc', 'def', 'xyz']
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou123,12,binjiang310')
['hangzhou']
</code></pre>
<h4 id="_20">“(?&lt;!…)”：不匹配…表达式，返回。对前进行匹配,总是对前面进行匹配<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'(?&lt;!\d)[A-Za-z]+')      #匹配前面不是数字的字母
&gt;&gt;&gt; pat.findall('abc21,def31,xyz41')
['abc', 'def', 'xyz']
&gt;&gt;&gt; pat.findall('zhoujy20130628hangzhou123,12,binjiang310')
['zhoujy', 'angzhou', 'binjiang']
</code></pre>
<h4 id="idname-yes-no">“(?(id/name) yes |no)”: 组是否匹配，匹配返回<a class="headerlink" href="#idname-yes-no" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'a(\d)?bc(?(1)\d)')   #no省略了，完整的是a\dbc\d ==&gt; a2bc3,总共5位，第2位是可有可无的数字，第5为是数字
&gt;&gt;&gt; pat.findall('abc9')                   #返回组1，但第2位（组1）没有，即返回了''
['']
&gt;&gt;&gt; pat.findall('a8bc9')                  #完整的模式，返回组1
['8']
&gt;&gt;&gt; pat.match('a8bc9').group()
'a8bc9'
&gt;&gt;&gt; pat.match('a8bc9').group(1)
'8'
&gt;&gt;&gt; pat.findall('a8bc')                   #第5位不存在，则没有匹配到
[]
</code></pre>
<h4 id="ilmsuxi">“(?iLmsux)”:这里就介绍下i参数：大小写区分匹配<a class="headerlink" href="#ilmsuxi" title="Permanent link">&para;</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; pat=re.compile(r'abc')
&gt;&gt;&gt; pat.findall('abc')
['abc']
&gt;&gt;&gt; pat.findall('ABC')
[]
&gt;&gt;&gt; pat=re.compile(r'(?i)abc')            #(?i) 不区分大小写
&gt;&gt;&gt; pat.findall('ABC')
['ABC']
&gt;&gt;&gt; pat.findall('abc')
['abc']
&gt;&gt;&gt; pat.findall('aBc')
['aBc']
&gt;&gt;&gt; pat.findall('aBC')
['aBC']
&gt;&gt;&gt; pat=re.compile(r'abc',re.I)           #re.I 作为参数使用，推荐
&gt;&gt;&gt; pat.findall('aBC')
['aBC']
&gt;&gt;&gt; pat.findall('abc')
['abc']
&gt;&gt;&gt; pat.findall('ABC')
['ABC']
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../python-mysql/" class="btn btn-neutral float-left" title="操作mysql基础"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/" class="btn btn-neutral float-right" title="字符串拼接总结">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright © 2022 - 2023 - lyvivian0077</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../python-mysql/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%BB%E7%BB%93/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
